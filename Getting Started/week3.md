 # M3.1.1 - Arrays
So, now we're moving on to composite data types. Composite data types are beyond the basic data types. They are data types that put together, that aggregate other data types. So, unlike a string. Even a string you can think of. Actually, a string is a special case because you can think of it as aggregating these different bytes. So, a string is somewhat of if I ask you. Now, I think about a string is a composite data type, but we're going to talk more generally about arrays right now. So, an array in general, is just where you take a bunch of a fixed-length series of elements of a chosen type. So, you can make an array of bytes, you can make an array of integers, an array of floats, and so on. But it's fixed length. That's the key thing about arrays, they are fixed length. It is known to compile time how big they're going to be. So, the compiler can tell, how much space in memory it needs to allocate for these. Just in general, let me say that these composite data types are important. That is, in any kind of complicated program, you're going to need to use composite data types. It's not enough to use the fundamental data types. Yeah. You need to bring together different data types and group them, and aggregate them into some kind of composite data type. So, you have different array elements. Each one is some chosen type, maybe it's an integer array, you've got a set of each array element would be an integer. Elements of the array, each element is indexed by using subscript notation. So, square brackets. You put the index right in the middle of the square brackets. So, we're going to have example here, but this is a similar notation what you see in a lot of different languages. Indices start at zero, because we're computer science, we start counting at zero not one. Elements are initialized to a zero value and actually, this is not always the case in other languages. Say in C, your making an array, that array is not initialized at all. Unless you actually write code to initialize it. When you create it, it's not initialized. In goaling, the array is initialized to zero value. When I say zero value, I mean the zero value of the type that the array is composed of. So, if it's the integer, the zero value is just zero. If it's strings, the zero value is empty string. So, in this example, we're showing how you can declare an array. So, you say C at the top, var x, and then in brackets five int. The fact that it has the brackets five, tells you this is supposed to be an array of five integers. So, that's how you declare an array. That would be initialized to zeros by default. Then next line I refer to a particular element x bracket zero. So, I'm looking at the zeroth element. I'm setting that equal to two. So, now I've changed that to equal to two. In the next line I'm doing a Printf. So, do Printf x of bracket one. Since bracket one, I didn't actually explicitly initialize that, it would have been initialized to zero. So, that'll print zero. So, that's an array. You've seen that in other languages most likely. An array literal, is a pre-defined set of values that make up an array. So, you use this to initialize arrays if you want to. So, for instance here, we say var x bracket five int. So, it's an array of five integers. We say equals and we say square bracket five and within the curly brackets, there are actually five integers. So, that's actually a way of initializing the array to a set of values, to an array of five integers. So, that array of five integers that's inside the curly brackets. That's actually called an array literal, and we're defining x to be equal to that array literal. The length of the literal has to be the same as the length of the array. So, if you declare x to be five, you better have five literals inside the array literal. Then this is operation that dot dot dot. That's actually a key word. So, dot dot dot is used to express the size. You can use dot dot dot to express the size of an array literal. You can do that because if you have an array literal and inside the curly brackets you have four elements in there, then it's clear that you want this array literal to be size four. You don't have to say explicitly four. So, you can just put a dot dot dot in there, and it will infer the size of the array from the number of elements inside the array literal. So, in this example, x :=, brackets we have.dot dot dot. We don't specify explicitly what the size is. This is int 1, 2, 3, 4. Since there's four elements in there, clearly you want x to be size four. The most common programming operation that you do to arrays, is to iterate through the array. You look through each element of the array and you do something with the element of the array. Maybe you add it to a sum or you check if it's greater than five or something like that, but it is extremely common in programming to iterate through an array and check out each element in the array. So, the way you do that in goaling, is with a four loop. So, you can see the code here, we've got some sample array one, two, three. It's just three elements in it, one, two, three. Now, we want to iterate through this array. Maybe we want to print out each element of the array. So, we make a four loop. Now, notice that I have highlighted near that range keyword. To the right of the range keyword is the name of the array that we want to iterate through. So, range x. To the left, we say for i, v. We got two variables here, i and v. I is the index of the array element that we're looking through in this particular pass, and v is going to be bound to the value of the array in element that we're looking at in this pass. So, the idea here is that in this loop, if you look inside the curly brackets, there's a print statement. That print statement is going to get iterated once each passes the loop. So, every pass of the loop, i and v have bound to different values. I is the index of the element that we're looking at, and v is the value. So, in this case, with this array, the first pass of the loop. I is going to be zero, next pass is going to be one, next pass is going to be two. They'll increment each time. V is going to be the ith value in the array. So, the first pass through when i is equal to 0, v is going to be equal to one because the first element in that array is the number one. So, the zeroth element is the number one. Then the next pass, i is going to be one and v is going to be two, because the first element from zero, one. The first element in that count is the value two and so on. All this loop does is very simple, it just prints out the i and v together, but that's the idea. This allows me to iterate through the array. So, i and v get bound to an index and a value inside this array on each pass. So, inside the loop, inside the curly brackets of the loop, we can do whatever we want to that value v and to that index i.

# M3.1.2 - Slices
So, Slice is a data type that you don't see in a lot of other languages. Slice is a really useful data type. So, a lot of times actually, slices are used instead of arrays, because they are flexible, you can change their size, you can increase them in size. So, let's talk about slices and how they're defined. Basically, a slice is a window on an underlying array. So, for every slice, there's going to be some underlying array that is the basis for the slice. The slice is just a window of it, a piece of it. So, you've got a long array of 100 elements, the slice is just maybe just three, four and five or something like that, or elements five, six, seven, eight, and nine, something like that. That's basically what a slice is, a window on a possibly larger array. It doesn't have to be larger, the array can be the same size as the slice. Then, the slice is just looking at the entire array, but the array can be much bigger than the slice and the slice can be just a smaller window on it. So, that's essentially what a slice is. So slices can have variable size, up to the size of the array. This is one thing that's really nice about slices, you can increase the size of the slice. An array is a fixed size thing. So, let's say I have an array of size 100 and I have a slice of size 10, which on that array and it's the first 10. I can increase the size of the slice to 20, and just look at the next 10 elements in the array and then I can increase to 30 and include the next 10 elements in the array. So, slices, you can increase the size of the slice, where you can't do that to an array. So, that's a good feature of slices. Now, every slice has basically three properties. One is the pointer that indicates the start of the slice. So every slice, since it's a window on an array, has to point to some element of the array that is the first element that is included in the slice. That's the point. The next thing in a slice, that's property of a slice, is its length, it's the number of elements in the slice. Because they all have a length. The third is the capacity. So, the capacity is the maximum number of elements in the slice. Now, that's defined by looking at the pointer which is the beginning of slice and looking at the difference between that and the size and the distance to the end of the whole array. Because a slice, it's size can be increased up to the size of the whole, up to the end of the array. So for instance, say you've got an array of size 100, you got a slice the size 10. You can increase that slice's size, say the slice starts right at the beginning of the array, you can increase the slice size all the way to 100, if you want to. So it has a capacity of 100. But, say you got an array of size 100 but this slice starts at array index 10, then it can only be increased to size 90, because by then you reach the end of the array. So the capacity of that slice is small. So, let's look at an example to see what I mean by these things. Slice examples. So, first we start with the underlying array. We got this array, we define it with this literal, it's got a, b, c, d, e, f, and g. That's the array, array of strings. Now, then we defined two slices on this, with that array as the underlying array, s1 and s2. Now, here's how we define these slices. We use this bracket notation, we use a colon inside the brackets to define the beginning and the ends of the slice. So, if you look at s1, s1 colon equals array, arr, bracket one colon three. The one is the pointer to the first element of the array, that is inside the slice, and the three is the index just after the end of the slice. So, that slice, s1, it includes array elements one and two, not three. So, the second number after the colon is just after the end. Now, if we look at s2. S2 colon five. Right, so S2 start at two. It include three and four, does not include five. So, we could see the picture down here at the bottom. You got the array in blue, the whole array. It has the a, b, c, d, e, f, g. Then in red, I've highlighted s1 and s2. So, s1, it includes index one and two because one colon three, so three is just past one past the N, and s2 includes two, three and four, and notice that these two slices overlap, and that's okay. If you look at s1 and s2, they both include array index two, and that's fine. Slices can overlap and refer to the same elements inside the underlying array. All right. So, the length and capacity, so there are two functions len and cap, which return the length and capacity of a slice. So, we got our array a1 here, and it's three elements long; a, b, c. Then, we define a slice, sli1 I'm calling it this time, and that is the array zero colon one. Okay. So, that means that this slice includes array index zero but not array index one. So, its length is actually one, should be one. It only has one element in it, array index zero. So, now the next statement, we do the print same. We print the length and the capacity. The length is one. Zero, zero is the only thing that's actually in the slice, but its capacity is still three, because its size could increase up to three if were to increase the size of the slice to go all the way to the end of the array since the array has three elements in it, and we are starting the slice at the beginning at array index zero, we could go all the way through array index zero, one, and two and the length of the slice could be up to three. So its capacity is three. Now, accessing slices or really referring to slices. So, when you write to a slice, to an element in a slice, you are writing to the underlying array. Overlapping slices can refer to the same array elements. So, you change one slice, you can change the underlying array, and you can change any of the slice that also accesses that, it also includes that array element. So, here we've got these in this picture, we show in this array. We got s1 and s2 are two different slices defined on it. See, in green, a circle that array element two, with the letter of the string c. So, that one is actually including s1 and s2. Now, in s1 with respect to s1, that is the s1 bracket one. It refers to that second element of the array, because s1 zero would refer to the first element of the array, because that's where s1 starts. So, s1 bracket one refers to that c, that letter c. Now, s2, that second element of the array, is the first element in s2. So, that's the same as s2 bracket zero. So, these two print statements will print the same thing, the letter C, because s1 bracket one is the same as s2 bracket zero. They're both referring of the same elements in the underlying array. Now, we talked about array literals, you can also have slice literals. They can be used to initialize the slice, just like an array literal can be used to initialize an array. Now, remember that every slice has to have an underlying array. So, when you initialize a slice, that means you're creating an array. You have to create the underlying array and the slice just covers the entire array. So, when when you use a slice literal to define a slice, it actually creates an underlying array and it creates a slice to reference the entire array. So, the length and the capacity of the slice are the same. So, if you do this, if you use a slice literal to create this array, its pointer will point to the beginning of the array and its length will be the length of the array and its capacity will also be the length of the array. So, the slice points to the entire array when you use a slice literal to define in this way. So, we can see that here, we're defining it using a slice literal. SLI is defined as a slice literal and it defines the underlying array. You know that this is a slice literal because you can see where I say sli colon equals brackets. Normally, in the brackets you'd put the length if it was an array, or put five or three in this case or you'd put least dot dot dot to say this is an array, it's length should be inferred from the number of elements inside the curly brackets. But in this case, we didn't put anything in the brackets. So, the compiler says," Oh this must be a slice," and what it does is it creates the underlying array and then it makes a slice point to the whole array.

# M3.1.3 - Variable Slices
So, there's a function called "make" that can be used to make slices, and you can make other things with it too, but right now, we're going to talk about making slices. So, the one way that we made a slice, the first when we talked about making the slice, we'll just to make the underlying array, and then make the slice after it. Also, you can initialize the slice directly with a slice literal, and we talked about that. This is the third way, you make the slice directly, but you're not initializing with any particular values. So, this is common. This is when its cases like this where you want to use a slice because it has its variable size, ability, and you don't care there's an array in the back, right, but you want to initialize a slice to a particular size, so at least at the beginning. So, one thing you can do is call "make". There are two ways to call it, you call it with two arguments or three. If you call with two arguments, the first argument is the type. So, the type of the objects that they're going to be inside of the slice. So, the slice of answer, slice of strings or something like that, that would be the first argument, Int, String, and then, the second argument is going to be the length of the slice. Now, when you use "make" to make a slice, the length is equal to the capacity, because it makes the underlying array, and the array is exactly the same size of the slice. So, the length and capacity are the same. That is, anyway, when you use a two argument version of "make". So, you can see here, SLI equals make, you say a bracket int to tell the type, and then 10. So, since I gave two arguments, it figures okay. Length and capacity are the same. So, the underlying array is the same size as the slice, and the slice points to the beginning, starts at the beginning of the underlying array. Now, the three argument version of "make", instead you specify the length and the capacity separately. So, that means that the underlying array is actually bigger than the slice. So, in this case, we got SLI equals make. But, first, we give you the first argument, the type bracket int. Second argument is the length of the slice. The third argument is the capacity, which is the size of the array. So, in this case, our slice is size 10, but the array is size 15, so we can increase the slice up to size 15 if we want to. So, there's an "append" function that can be used with slices, and it's used to increase the size of a slice. So, if you want to add stuff onto the end of a slice, and increase the size of the slice in doing so, use the "append" function. Now, note that this is a key advantage compared to regular arrays that you see in regular languages. You can't just add things to the end of an array and continually increase its size, but with the slice you can. So, it adds the element, you can add one or more elements. In this case, we'll do one, but it adds the element to the end of the slice. Which means, it inserts it into the underlying array, so it increases the slice up to the capacity of the underlying array, and it increases the size of the array if necessary. So, if you reach the limits of the array size, it'll make a new underlying array that's bigger. So, append never has to stop appending. You can continually append even beyond the size of the array, and it will just increase the size of the array. You don't want to do that, there's a time penalty for that, but it'll do that. So, as an example, we make a slice, SLI, we call "make". So, the length of the slice is zero, but the length of the underlying array is three. So, then, I want to put something into the slice. So, the slice is empty, right, the size is zero. So, I say, I append the number 100 onto the slice, so I call "append". I pass the first argument, I pass the slice and the name of the slice, and the second argument is 100, that number that I want to put into the slice. So, it puts it in, in order to add that on, it has to increase the length of the slice. So, now that the slice of length will be increased to accommodate the new number that it put in there. So, that's how you would use "append" in general.

# M3.2.1 - Hash Tables
A hash table is a data structure used in a lot of different languages, and it's very useful data structure, it allows you fast access to large bodies of data. Hash table generally contains a key value pairs, so there are a lot of values inside this hash table but each value is associated with a unique key. So, for instance, maybe social security numbers and emails, right? So, social security number might be the unique key of the person and so that might be the key and then the value might be the email address of the person. So that's a pair. The unique key and value and the key has to be unique that's actually completely important. Also maybe like GPS coordinates and address. So every address has a unique set of GPS coordinates associated with it. So GPS coordinates might be used as the key and then the address might be your house address, right? Which may or may not be unique. Where you live there a lot of different street, main streets in the world and there can be a lot of different one main streets. So that might not be unique but the GPS coordinates have to be unique or the key has to be unique in this case GPS coordinates. So, a hash table is meant to store these key value pairs, and it is important that each key is unique. So a hash function is defined and is used to take a key and compute a slot in the hash table to insert the value according to the key. So, you can think of a hash table is something like, I hate to say it, but think of it like a big array. It's got a lot of slots where you can put values in there. Now which slot puts the value in is based on the key. A hash function is used to process the key, and generate the number of the slot that you want to insert the value into. So, a hash function is a function that takes as its argument the key and it returns the slot where you want to put the value. Now by the way this hash function, you never call this hash function explicitly. This is something that goes on behind the scenes inside the Go language but just to understand there is a hash function that does this. So, here's an example of what a hash table might look like. So, at the top we've got this little table, a bunch of keys, and values. So, my keys are Joe, Jane, and Pat, they're all unique keys, their strings are unique, and there are some values x, y and z, they're arbitrary. So Joe is associated with x, Jane associated with y, Pat associated with z, and I want to put these three key value pairs into my hash table. So, if you look at the bottom you got on the right, you've got this basically an array of some size and this is a small one but this is just an example. So you got some array and the values x, y, and z are all placed in different slots inside this structure. So, and I just place them arbitrarily, Y is in location one, and X in location three, Z is in location five, right? So, they're in some arbitrary location, some slots inside the structure. Now then over on the left, you can see the keys Joe, Jane, and Pat. Now there in between there's this hash function and the hash function it takes the key and it determines which slot it is going to place the corresponding valuing in. So, I drew this within the line, so if you look at Joe, there's a blue arrow that goes into the hash function and then points to location three, slot three. So, Joe is associated with slot three which has the value x, and then Jane, the hash function will compute a one in this case. So, slot one has Jane's value y and then likewise with Pat, Pat is associated through the hash function with slot five and then you put its value z inside slot five. So, this is the idea behind a hash table. So, the reason why this is good is something like an array or slice, right? You can access things in constant time, but you don't have to use indices to access them, you can use arbitrary keys as long as the keys are all unique and constant then you can use a key. So, normally if this were an array if I want to access entry one, element one, I'd have to say the name of the array and then brackets one. In this case, I can say brackets Joe or bracket Jane or bracket Pat or something like that. So that's actually useful, the naming is useful for several reasons. One reason is, it's easier for a programmer to remember Joe, and Jane, and Pat rather than arbitrary numbers. The numbers have no particular meaning with respect to that particular application you're writing, where Joe, and Jane, and Pat, they are people and they have some sort of a meaning in the mind of the programmer. So it makes it easier to code. So, advantages. Advantages are fast lookup table than lists. So this is an advantages compared to like a list that you'd find in another language. Faster lookup in lists because in a list, it's linear time lookup. So that means if you want to find an element in a list, you have to start at the beginning of the list and go to the next, and next, and next and keep comparing until you find the one you want, find one that matches. That's linear time, the longer the list is the longer it takes to find things in the list on average. Where this is constant times much more like an array, right? Basically you take the index, the key rather, you use the hash function which takes some constant amount of time and it gives you the index and you go straight to that index. So, it's a constant time lookup rather than linear time like you would find in a list. Now, another thing about it is that you can use arbitrary key, so this is better than say slices or arrays where you would have to use integers. You can use arbitrary keys and those keys can have some sort of a meaning to them. So, disadvantages is that you may have what are called collisions inside your hash table. So collision, is when two keys hash at the same slot. So, Joe, and Jane if the hash function maps both of those to slot two, then you have a collision. Then Joe's value and James value both have to go into the same slot. Now, there are ways to handle these collisions. You can put them both in there and put them in a linked list or something like this but, when you get collisions, the speed gets a little slower, right? Because those collisions have to be handled in some way. So, you don't have to worry about how they're handled, that's built into Go, but that can slow you down but, I'll say this that collisions are rare because the hash function is made in such a way that collisions are very rare, okay? So, this is a possible disadvantages with collisions but, it's not likely to cause you many problems.

# M3.2.2 - Maps
So, a map is Golang's implementation of a hash table. So, a map is exactly a hash table. You can use the make function to create a map. So, we have an example here. So, first thing I'm doing, is I'm declaring idMap as a variable, a map variable. So, I say var idMap and it's going to be a map and notice it afterward the keyword map, I have in brackets the word string, that's the type of the key, and then after that I have another type and that's the type of the value. So, the key and the value can be different types. Then, the line after that, first I'm declaring idMap to be a variable then I'm actually assigning it, pointing it to a map, making an actual map and I call make for that. So, idMap equals make and then parentheses map string int. So, it creates a map. Now, at first, this make is going to create an empty map, but it creates a map. Now, another way to define a map is you can create the map with a map literal. So, you can initialize it with values, with key value pairs rather. So, I'm sure on that down here, idMap colon equals map string int and then in curly brackets I list a bunch of key value pairs, and value are separated by colons. So, in this case there's just one pair but you can have a comma separated list of key value pairs. In this case, it's Joe colon one two three. So, Joe is the key, one two three is the value. So, you can put any number of those. You can initialize it with any number of those key value pairs. Accessing maps. So, how do you access the elements in a map? At first, actually most of it is the same as the way you would access an array except the index that you use, that you put in between the square brackets, that's actually the key. So, if I want to read the value associated with the key Joe, I can say, in this case I'm doing to print, fmt.Println l idMap and then in brackets I say Joe. I give the string Joe and that will return the value associated with Joe and it'll print that. I can also add a key value pair into the map, or change an existing one if it's there. So, if I want to add some new key value pair, I could say idMap Jane, maybe there's no key Jane in there right now, I idMap Jane in brackets equals four five six. So, that puts a new key value pair in there. Now, note that would also change a key-value pair. So, let's say there was already a key value pair in there, Jane was mapped to six, seven, eight. So, if I by saying idMap Jane four five six, I am getting rid of the old key-value pair associated with Jane and I'm putting a new one in there. So, Jane is now associated with four five six. Also you can delete a key value pair from the map without overwriting it. You can just delete it completely by calling the delete function. You call delete, you pass it, the first argument is the name of the map, so idMap. Second argument is the key that you want to delete. So, in this case Joe and it will eliminate that key-value pair Joe and whatever its value is. It will eliminate that from the map. So, there are also a few more map functions. One thing that you can do with maps, is you can have a two value assignment for a map. So, for instance here, I'm saying id comma p colon equals idMap Joe. Now, when I do that assignment, if I had just done a single value assignment say, I said id colon equals idMap Joe, then ID would equal the value associated with Joe. In this case, I'm doing a two value assignment. So, the second value, id comma p that p is going to be a Boolean. It's going to be true if the key is present in the map. So, there are cases where you're interested in knowing whether that key is in the map, maybe you don't even care what the value is associated with Joe. You just want to know if Joe is in your map. So, p will be true if that key Joe in this case is in the map and really false otherwise. There's also length function you can apply it to maps and if you do, you say like here I'm saying I'm printing len of idMap, it will tell you how many key-value pairs are inside the map. Another thing which is very common to do, is to iterate through an entire map, just like iterating through an array, very common thing. You want to iterate through every key-value pair. So, what you do here is you're using basically a two value assignment with the range keyword. So, it's a for loop. So, if you look at the for loop, you got the key and then the value, key comma value and then the colon equals range on the ID map. So, what that does is every pass through the for loop, key is going to be equal to the one key inside the idMap and val is going to be equal to the corresponding value in the idMap. So, in this way, every pass, every iteration through the for-loop, will use one key and one value pair. So, key and value will be bound to a different key-value pair for every iteration to the for loop and you'll iterate through the for loop until you've gone through every key-value pair inside the idMap.

# M3.3.1 - Structs
So, a Struct is another aggregate data type, another composite data type, as an aggregate type meaning groups together objects of arbitrary data types into one object, and it's useful for a lot of things, usually it's for organizational purposes, it really helps. So, let's give an example, easy way to talk about it. You got, let's say you want to make a Struct, Struct is short for structure by the way, and by the way this is taken also straight from say C, C are Structs too. So, say I want to make a structure that describes a person, a Person Struct. So, say every person has certain features a name, an address and a phone number. So, if every person, I want to represent these three different aspects of a person. So, one option would be to have three separate variables, for every person I'll have three separate variables and the programmer has to remember that they're related. So, maybe I have named and I might use naming for that, so I might say we'll name one, address one, phone one. I have three different values, right? I put one after all them so I, as a programmer, can remember, "Okay, this is name one and address one and phone one, they must be related, they all have one after them, right?" The next person I make, I'll call it name two, address two, phone two, and so on. So, that's one way. In that scenario, these three pieces of information name, address, phone, they are related, they have to be, the program of themselves has to remember that they're related. Okay? That this name is related to this address and this phone, where this other name is related to this address and this phone. Now, another way, probably better way to do this option two, is to make a single Struct, that represents a person and that Struct, it aggregates all three variables. So, this one object now contains a name, address, and phone number of one person. So, they are related because they are in the same object and so when you're accessing them, it is obvious, that if you're accessing them from the same object, you know that they are related to the same person. So, that's what a Struct is for, for bringing together different variables that are related in the application and putting them together so that you, as a programmer, know that they are related and they're related to the same person or whatever the object is in, in the application that you're talking about. So, here's an example of a Struct. You've got, so we're defining a type, a Struct type and we're going to call it person and this person has three fields, three pieces of information, a name, address, and phone number. So, notice how I'm defining this Struct type, it's called person, I give its name as a person and each one of these fields, name, address, and phone has a type, name string, address string, phone string. After that, once I define this type, I can define any number of persons, I can say var p1 is a person, var p2 is a person, and so on, and p1 in this case, it's going to have a name, address, and phone number on its own. So, each property is called a field, so name is a field, address is a field, phone is a field, and p1 can have values for all of those fields that are unique from another variable p2, which is a person or p3, so I can have any number of persons in there. So, if I want to access the fields of the structure, by access I mean, read from them or write to them, change them, I use dot notation. This is not like with arrays. With arrays, you use a square brackets, you use an index, use dot notation here. So, p1.name, if I want to assign that to Joe, I can say p1.name equals Joe and that will sign the field, the name field of p1 to string Joe. Also I can read in the same way, I can say x equals p1.address and that will assign X to be the address of p1. So, use dot notation rather than the brackets that you would use with arrays. Initializing structures, you can initialize them using the new function. One way to make an empty Struct, it initializes all the fields to zero, zero values. So, like in this person structure, the values are all strings, right? So, the zero value is going to be empty string. So, I can say p1:= new person and it'll make a new person that's empty, so zeroed out. So, the name, address and phone number will all be empty string. Another way you can initialize the structure is you can initialize it with a Struct literal, so if you want to give values to all the fields when you create the person and we're showing that here, p1: = person, then in parentheses, I'd give the Struct name, let's give this a Struct name and then Struct value, right? So, name: Joe, address: a.st, a street and then comma phone: 123. So, in this case, I'm using a Struct literal and I'm making a new structure but I'm also assigning all the fields to different values Joe and a street and 123. So, I can do that too.