# M2.1.1 - Pointers
So, in this module, we're going to talk about basic data types, and we're going to start with Pointers, which maybe is an unusual place to start the discussion of data types, but that's where we're starting, because people who are taking these courses generally already know something about programming. So, let's go straight to these Pointers and talk about them. A pointer is an address to some data in memory. So, I got to say every variable is located in memory somewhere, in some data staying in memory somewhere. Also, functions and so on, they're all in memory somewhere. A pointer is the address of that in memory. Tips give virtual address but that doesn't matter to us too much right now. So, with Pointers, there are two main operators that are associated with Pointers. The ampersand operator right there, that returns the address of the variable or the function, whatever the name is referring to, and the star operator which dereferencing, does the opposite of the ampersand. It returns the data at the address. So, the ampersand operator, if you put that in front of a variable, the name of a variable, that will return you the address of that variable. The star operator goes the other way. If you put that in front of a Pointer, to some address, put that in front of an address, it will return you the data at that address. So, it's important to understand this ampersand operator and the star operator are opposites of one another. So, I'll give you an example, take the look at this code, little piece of code, we define our variable X is an integer, it's equal to one. Then, Y is an integer and it's not initialized, so that would mean it would be by default initialized to zero. Then, a var IP. So, IP is not declared to be an int, it's a star int. Right? So, that means IP is actually a Pointer since there's a star operator in front of the int, IP is declared to be a Pointer to an integer. So, IP is the Pointer, but it is not an actual integer, is a Pointer to an integer. So then, if we go on, IP equals ampersand X. X is actually an integer. Right? Integer whose value is one. So, there is a number one sitting in memory somewhere, and X is a reference to it, the name of that. Ampersand X is the address in memory where I can find that value one. So, IP is now equal to that address. So, whatever the address of that one, is rather, of X, whatever that address is, IP is the Pointer to that address, it is the address. Then, in the next line, I say Y equals star IP. So, remember that in this little example, IP is actually a Pointer and the data at that address that IP is pointing to, is the value one. Now, star IP, star does dereferencing. Star says, star returns the value, the data at that address. So, Y is now equal to the data at the address that IP is pointing to. Now, if you remember for line for IP is pointed to what X is pointing to. Right? So, IP is pointing to the value one, that data in memory. So Y, if Y is equal to star IP, Y is equal to one. So, this now sets Y equal to one. It is just a little example here, just trying to show how the ampersand and the star operators work opposite to one another. So, these are Pointers, and Pointers exist. These Pointers are basically, if you now see same type of implementation. Now, there's another function called New. It's another way to create a variable. New, instead of returning a variable, it returns a Pointer to the variable. So, the new function creates a variable and it returns a Pointer to that variable. So, this is unlike, if we're just declaring a variable, right? That also creates a variable, but New explicitly returns a Pointer to a variable. So, the variable is initialized to zero by default with New. So, for instance here, if I say our Pointer equals new int, and then star Pointer equals three, right? Pointer was new int, new int returns me a Pointer to an integer, and that PTR is equal to that Pointer. Then, I can set the value of that integer by referring to star PTR, right? Because star PTR is the value that PTR is pointing to. If I say star PTR equals three, then the value three is placed at the address specified by PTR.

# M2.1.2 - Variable Scope
So, we're going to talk about what the scope of a variable is. Roughly, the scope of a variable is that the places in the code where a variable can be accessed. So, variable scope defines how a variable reference is resolved in the code. So, if you reference a variable x, how does the program figure out which variable actually talking about. That's basically what variable scope is. So, these little examples just to show you an example of scope. If we look at the first block of code, we got this variable x, I'm highlighting in red. This variable x is defined outside of these two functions. So, I've got these two functions defined. Function f and function g. But outside of both of them, I define this variable x. So, var x equals to, wherever it is, one. Then, I defined my function f and function g. Now, if you look inside function f and g, the're very simple. All they doing is they're printing x, they're both printing x, is all they doing. So, inside function f and inside function g, when you call these functions, they've got to figure out where to find the value for x. Now, in this case, they're going to find the value that I've defined outside. So, where I say var x equals one, when they print out x, they going to print out one for x. Because of the scoping rules allow that. So basically, because it define outside of either one of these functions, then both of them will have access to it. We'll define the formal rules for that in a few slides. Now, the next block of code, you get a problem. Because the next block of code again, you've got function f and function g, but this time variable x is defined inside function f, but not inside function g. It's only inside f. So, function f will print properly because it'll look at x and resolve it since it's defined locally, right there inside, it's functional. So, x is equal to one, and it'll be happy. But function g will have no reference to x. It won't be able to see that and it'll throw an error when you try to run that, because they won't know what x is. So, this is the type of problem that needs to be resolved, you don't want to run into this type of problem. You want to be able to know where your variables get resolved to. So that you don't have problems like this. So, we're going to talk about variable scoping right now. So, how does the compiler figure out where a variable reference should be resolved to? Which x are you talking about? It's this x versus that x. So, in Go, variable scoping is done using blocks. Now, block is a sequence of declarations and statements within matching curly brackets. So, those curly brackets right there, you have an open curly bracket, closed curly bracket, everything in between is called a block. So, that's how you explicitly define blocks. You notice how these blocks can be hierarchical. You can have curly brackets and then within that you can have some other curly brackets and within that you can have some more. So, you can have this hierarchy of blocks. These are explicit blocks. When you put the curly brackets in your own code, those are explicit blocks that you, as a programmer included. Our function definitions notice, are defined by curly brackets. We haven't gotten to functions, we'll talk about it more later. But every function definition, you define the function, gives the name of the function, and then you have open curly brackets, closed curly brackets. Every function, you got curly brackets. So, there's a hierarchy of these curly brackets and hierarchy of these blocks. Now, also there implicit blocks inside this hierarchy. So, there are blocks that are implicitly defined without the curly brackets. So, just to list those blocks, first is the universe block. That's all Go source code, that is the biggest block, the universe block. There's a package block. So, every package, you don't put curly brackets around every package at all the source code in a particular package, that's all within one block, which is inside the universe block. Then, there's file block. File block, all the source code in a single file is within the file block, and remember that package can be composed of many files. So, there can be one package block that has many file block if you got a lot of files inside the package. Now, then other implicit blocks include the if statement, for statement, and switch statements. All these have curly brackets that define their own blocks. Also, the clauses inside a switch or select. We'll get to these in more detail later. But these are all, all the ones I'm listing here are these implicit blocks that you don't have to put explicit curly brackets for. Well, so you can. So, for instance, an if statement, you can use it curly brackets too. But like the universe block, the package block, file block, these are all implicit blocks and there's a hierarchy of these. So, this is my point, that there's this hierarchy of these blocks and each block can have its own environment variables associated with it. So, lexical scoping. This defines how variable references are resolved. So, Go is a lexically scoped language using blocks. So, when we talk about lexical scoping, we've got to talk about this relationship of one block being defined inside another block. So, I'm using this terminology here, I'm saying bi is greater than/equal to bj. If bj, b is a block. If bj is defined inside bi, then bi is greater than or equal to bj. So, I would say that bj, if it's defined inside bi, bj would be, I refer to it as an inner scope, where the outer scope that includes bj is bi. So, just as an example of this, it's a transitive relationship, but just as an example of this, look at the code. We got, we've seen this code before. Got variable x, we'd initialize it to one. Then, you got a function f and function g. Now, if we look at the blocks inside here, first you got, this is all in one file. So, all of this is inside the file block and I'm calling that b1. So, b1 is my file block and everything is inside the file block. But in addition to the file block, I'm defining two function, f and g. Each one of these function blocks, the functions gets its own function block, so b2 is the function block for f and b3 is the function block for g. So, if I were to look at how these blocks are related, a b2 and b3 are both defined inside b1. So, I say b1 is greater than b2, and b1 is greater than b3 by my definition, because b2 and b3 are defined inside b1. But notice that there's no relationship between b2 and b3. Because they're not defined within each other. So, we need to know this, because the scoping rules, when you're resolving a variable, you go to the greater including scope. So, for instance, if inside b1 the function f and inside of that block, you're referring to variable x. Then, it's going to look for that variable x inside b2 itself, inside its local block. But then, it looks for the next bigger block that is defined inside. So, it starts in b2, looks for the block, it looks for variable x. If it doesn't see it there, which is not defined there, in this case, then it says, "Okay what is the next bigger block that I've defined inside?" It would get b1, and when it look inside b1 and say, "Ah, there is a definition of x here." That's the definition of x that it would use. Same goes for b3. If you look at the function g, it uses variable x, it access variable x. First it looks inside its local block b3, it doesn't see it. So, it looks inside the next bigger block that's defined inside, b1 and it sees it there. So, that's why this works, this why this code will work. The x will be resolved properly, so that x equals one, that variable that we defined inside b1. So, when you're talking about scope variables, a variable is accessible from a block bj, if the variables declared in some block bi, and block bi is greater than/equal to bj. So, it's either the variables you declared right there in bj or it's declared in some outer block that's greater than bj. So, that's why in the first block of code, first block of the first step code sequence, you can see where x is defined inside the file block. Both of those functions, which are also inside the same file block, they can both properly access the x variable because their function blocks are within the file block. But in the next block of code, next sequence of code, the x is defined inside the function block of f. But it's not inside the function block of g. So, when g tries to reference x, the variable x, it doesn't see it in its local block. It also doesn't see it in its file block, because now the definition is inside the function block for function f. So, that's why this fails, x doesn't get resolved back to anything and there's an error.

# M2.1.3 - Deallocating Memory
So, we've been talking about variables and how they're referenced. Variables, they're all referring to some data that somewhere in memory. So, the variables eventually have to be deallocated in memory. So allocated and deallocated. So what I mean is once you declare a variable and your code is running your space needs to be allocated somewhere in memory for that variable. If it's an integer, there has to be some allocated space dedicated to holding that integer and at some point that space has to be deallocated. When you're done using it all right. So, when you're done using your variable X, you want to be able to say "Oh that space is now free and it can be used for other purposes." So, that's deallocation, when you make memory space available for other purposes. You have to do this in a timely fashion. So, otherwise you eventually will run out of memory and your machine. So for an example, you look at this piece of code it declares a variable X, var X equals 1, so the process when it runs it has to allocate a memory location just for X to hold it. Now say you call in your program you call this function f 100 times right, then it's going to allocate 100 different spaces for this variable X right, because the X goes away after the function completes the X goes away it's going to allocate it again it should go away, you want it to go away. But every time if you don't deallocate it, you'll execute, every time you execute this function f you will get a new variable X allocated and so you'll have all these spaces allocated in memory and really you don't need them anymore right? I mean once a particular function call ends you no longer need the space for the X that it was using. So, at some point you have to deallocate this memory. You have to say "Look this memory is now free, " because otherwise you would eventually use up all your space and you might think well, how am I going to use it my space I've got X number of gig in my memory system. You can eat that up very quickly and believe me this is called a memory leak this is a thing that happens in C a lot. You can eat up all your space very quickly. So, you have to deallocate this space in a timely fashion. Now in order to talk about how space is de-allocated, we got to talk a little bit about where the space is stored in memory. So, memory is a big thing but there are two big hunks of memory that are relevant to us right now, the stack and the heap. Now the stack is an area of memory that is dedicated to function calls, primarily dedicated to function calls. So, one of the things is stored in the stack are the local variables for a function. So every time you call a function there can be variables that you define in that function and generally they go into the stack. They are allocated in the stack area of the memory and they're deallocated. If they're allocated in the stack, they are deallocated automatically when the function completes. Now this is this is different a little bit different for go. This is traditional. What I'm talking about now is how it works in regular languages. Go change this a little bit, okay. But normally the stack is the area of these local variables where when the function is done, the variables are deallocated automatically. Now the heap on the other hand, is a persistent region of memory where when you allocate something on the heap it doesn't go away just because the function that allocated it is complete, that heap memory it you have to explicitly deallocate it somehow in another language. So if you were in say C, you would have to explicitly deallocate this. Now Go does a tweak on this. But it is still important to understand that memory variables can be in the stack which will for the most part automatically go away when the variable, will be deallocated automatically when the function is done or in the heap where it's persistent. Now if you're in another language like C, then you have to manually deallocate things on the heap. The stuff that's on the stack you don't have to manually deallocate it, it will go away when the function completes. But stuffs on the heap you have to manually explicitly deallocate it. So, say you were working in C, if you want to allocate memory on the heap, you would call a function called malloc, and I say I say X equals malloc 32. It'll allocate 32 bytes of memory and X will be appointed to that and then later when I'm, that's how you allocate it. Later when I want to free it I'd say free X and it will free that space deallocating it. So, error prone but fast. So, what I mean by that is, it's error prone because it's easy to make a mistake in your allocation and deallocation. Deallocating at the wrong time or forgetting to deallocate it stuff like this, it can cause headaches. So, it's error prone in that sense but its fast. The implementations are very fast. What happens with deallocation in an interpreted language is that the interpreter does it okay and that can take time. So but in a compiled language like C, you would have to do that manually.

# M2.1.4 - Garbage Collection
So, we've been talking about deallocation, deallocating memory, and it can be hard to determine when it is appropriate to deallocate a variable. Reason is because you can only deallocate a variable when you know the variable is no longer in use. You don't want to deallocate a variable and then later need that variable that you deallocated, because then it's basically gone. So, it's hard sometimes to figure that out, figure out when it's not in use or when it is in use and so on. So, here's an example, a Go example. This is legal in Go but because this is a pain, his is not legal in certain other languages but in Go this is legal thing. If you look at the first function foo. Inside there we declare this variable x. So, It's a local variable to this function foo and what's returned though is the address of x, f say x, write a pointer to x. Now, then in the main function down below, the main function calls foo. Then, the main function, what happens is since it calls foo and it gets the return value of foo actually gets assigned to a variable in the main function. So, the trick here, the confusion here, is that this program foo normally, if you declare a local variable x when the function ends that variable x should be deallocated. Right. You're done with it because the function is done with it. But in this case it's not the case because is returning a pointer to x. So, now the main, since the main now has that pointed to x since that's getting returned to the main, the main might still use that pointer to x. So, you can't just say "foo is now done, I can get rid of its local variable x because maybe main is going to use that local variable because now main has a pointer to it". Okay. So, this is actually a legal thing to do in Go. So, this is just one example of how pointers especially make it difficult to tell when deallocation is legal and when it's not. So, deallocation is a complicated thing. So, what people do? One way of dealing with that is to have garbage collection. So, garbage collection is basically automatic or an automatic tool that deals with deallocation. So, this is part of interpreted languages and this is done by the interpreter, so if is, say Java, the Java Virtual Machine or a Python is a Python interpreter something like that. It keeps track of these pointers and it determines when a variable is not in use anymore and when it is. Once it determines that a variable is definitely not used, there no more pointers, no more references to that variable then the garbage collector deallocates it. Only when it all references are gone. So, this is nice, garbage collection is a nice thing. It's easy for the programmer. Right. Programmer doesn't have to worry about exactly when deallocation, when to do it, when not to do it. Believe me deallocating memory is a big headache, in other lang say C or something like that. But, it requires an interpreter so generally compiled languages like C, C++, they can't do it, but Go is different. Okay. Go is different and better in the sense. So, Go is a compiled language which has garbage collection built into it. So, that is a unique feature Go which is really nice. So as a result, the Go compiler can figure out when to follow these points is to some extent and figure out when this point you're still in use. It basically, keeps track we're not going to go into Go garbage collection because that is the complicated thing. There are many ways of doing it but generally you have to keep track of the pointers to a particular object. Once all the pointers are gone, then you know that the object can be deallocated. So, garbage collection in Go allows two things. One thing is, it will actually allocate stuff on the heap and the stack itself. So, you as a programmer don't have to determine, I want to put this on the heap I want to put this on the stack. The Go compiler, it'll put code in there at compile-time, it'll figure out this needs to go heap, this needs to go to the stack and it'll garbage collect appropriately. So, if it's on the heap it will garbage collected appropriately will see when all the pointers are gone and it'll determine when it can be deallocated. This is a really helpful thing. Now, there is a downside because the act of garbage collection does take some time. Right. So, there's a performance hit but it's a pretty efficient implementation and garbage collection is so darn useful is probably worth it to put it in Go. So, that's a trade-off that Go makes. It slows things down a little bit but it is a great advantage because it makes programming a lot easier. You don't have to go as far as using a full-on interpreter like you would in an interpreted language.

# M2.2.1 - Comments, Printing, Integers
So, we're going to continue talking about the basic data types, but a couple of things I want to hit on are comments and print statements. So, it's interesting when teaching a class about programming language, there are some things that you have to teach it linearly, right? One thing at a time. But some things are basic concepts that I have to use very early on. So, I'm going now to sequence a little bit, but these are comments and print statements I use all the time, I've even used them already. So, I need to define those then I'll keep going with the variables. So, comments. Comments this is pretty straight forward, these are basically C like comments, they look like this the same as in C. Single-line comments are just a double slash or slash-slash. Everything to the right of the slash-slash on the line, that's a comment. Which means it's completely ignored by the compiler. It's only text for the programmer to look at, to understand, to help with the understandability of the code. Which is a useful thing. Comments are excellent things when used appropriately. But you can see here, you can see slash-slash, this is a comment and then everything to the right of it, which is everything on that line is going to be comet stuff I've highlighted in red there. Then on the next line, I declare a variable var x-int, and I say slash-slash another comment. In that case, the slash-slash, everything to the right of the slash slash on that line is comment, but the stuff on the left is still valid code. So, the stuff on the left gets compiled, the stuff on the right is ignored by the compiler. Now, in addition to the single-line comments, you got blocked comments, and those are marked off with the slash-star and the star-slash. Slash-star begins that star slash ends it. Everything between the slash-star and star-slash is a comment. So, in this case it's just two lines, but I can have any number of lines of code. If I wanted to have a lines of text whatever, I can have any number of lines of text describing a function or something like that mark that, put that as a block before the function if I wanted to. So, those are comments. Now, an additional thing that I've already been using print statements just because they're so useful. Printing, it's done using the format package FMT package. So, you have to import the format package import format at the top of your program. Then printf is the first standard print function you use. A format.print it prints a string. So, it passes a string as an argument to printf. So, format that printf quote tie. A string is delimited by these double-quotes, and we'll talk more about strings but the stubble ways just double-quotes. Or I can say x equals x colon equals Joe, and then format our printf i plus x, so plus the concatenation operator, that concatenates the Hi and the next string x. Right. Which is a word Joe. So, that would print out Hi Joe with space in between. Now, we also we're going to use format strings. Format strings are strings that are used for formatting the output, to make it look nice. Basically, all format strings are there strings in double-quotes, but inside the string, use what are called conversion characters. So, in this language they're, in Go they use percent. Percent, and then some of the characters. So, for instance, you look at the example format printf says hi, and then percent S. Percent S is a conversion character for a string. So, what's going to happen is wherever you see the convergent character, that character will be substituted by some variable in this case this is percent S that means a string. So, it expects a string. So, if we look at the arguments to printf, the first argument is the Hi, is the string hi percent s, that's a format string. The next argument, is the x. That x is going to be some string that is going to be substituted in for the percent s. So, if x is the word Joe, then when I do this print statement, it's going to say Hi Joe, because Joe will be substituted in for the percent s. So, this is a commonly used, these format strings are commonly used to make the format look nice when you're printing. So, besides the comments and the printing, let's start talking a little bit about integers and the nature of integers. So, first there's a generic int declaration we've already declared some integers are var x int. Now, there are different varieties of integers. Generally, for the most part we're not going to care, we just say var x int, and leave it to the compiler to figure out what type of integer, what length of integer it to use most of the time. But you can have different lengths of integers too. So, for instance here, you got int8, int16, and 32, and 64 and those numbers are the number of bits that are used to represent the integer and memory. So, eight-bit integers, 16-bit 32-bit, 64-bit. Then you want unsigned integers. So, and also eight-bit, 16 bit, 32, 64. That is we aren't unsigned. So, that means that they can get larger. Meaning, there's a normally and we're using two's complement arithmetic inside our machine. So, the most significant bit is the signed bit. In an unsigned integer, that most significant bit is not used for the sign, it's used for magnitude representation. So, the magnitude, the absolute value of the unsigned integer can get bigger just because you have that extra bit that would have been used for signing and irregular integer, you can use it for magnitude. So, the difference between these different lengths of integers is just how big do we need the integer to be. So, an eight bit integer let's say, that can only represent x, let's say it's an 8-bit onside the sound side for a second, that can represent zero to 255, because that's the biggest number you can represent with eight bits. But a 16-bit integer can go from zero, like an unsigned integer can go from zero to 64K, which is about 65,000 and there about. So, it's much bigger. So, the more bits you use, the bigger the number representation can be. The most common thing to do, is just to declare it as an int and leave it to the compiler figure out, but if you happen to know the magnitude of the numbers that you want, you can control that by specifying what size integer you want. Now, integers also have a set of operators, binary operators I'm showing right here. They're also unitary operators but these are the binary ones. These you've seen these in every language, plus, minus, times, all the arithmetic, shift, modulus, comparison operator, so equal-equal is a comparison, equality comparison. Part ahead exclamation equal, that's not equal. Greater than, less than, so forth, there are Boolean operators, so and or, and then bitwise operators, where it does Boolean operations per bit inside wherever the integer is. So, you can see those too, but these are common to basically to all, not all, but all standard languages have the same set of operators that you can operate on interests with.

# M2.2.2 - Ints, Floats, Strings
So, we talked about integers. Now, let's talk about type conversions a little bit before we go on to the next basic types. There are cases where you need to convert a number or a value from one type to another type. For that, you use the type conversion. Now, these conversions are not always possible. You can't necessarily do those conversions, but when they exist, when you can do them, here's how you do them. Let's say, for instance, you've got some integers of different lengths. So, I've got variable X. It's a 32-bit integer, and variable Y, it's a 16-bit integer. I want to say, X equals Y. I want to assign one to the other. I want to do some operations with them together. That, as shown, would actually fail. Reason why they'll fail is because these two integers, they're actually two different types of integers. So, the compiler sees them as two different types. Int32 is a different type than int16. So, it'll throw an error when you try to set one to the other, because when you assign like that, the two things, the things on the left-hand side and the right-hand side, they have to be the same type. It sees them. Even though they're both integers, the fact they're different length means they're different types, and it throws an error. So, in order to do this, you've got to convert one to the other. So, for instance, you might say, let me take that Y, which is an int16, and convert it to an int32, and then, assign X to that. Then, that would work. So, the way you do type conversions like that is, you use this T operation, where T is the name of the type. So, if I want to convert Y int16 into an int32, I just use this built-in function int32. That will take whatever its argument is and try to convert it into an int32. So, X equals int32 Y. That's what it would do: take Y, which is int16, convert it to int32. Now, this is a conversion that is possible. All it has to do is, its sign extends the Y integer. So, the Y value, you don't want to change Y's value. It's equal to two. So, Y is a 16-bit version of two, and they want to make it into a 32-bit version. So, what it's going do is, take the sign bit and just extend it. So, if the sign bits is zero, meaning it's a positive value, it just puts 16 zero bits, and the high bits gives you a 32-bit number, which is equivalent, and also, a 32-bit representation of two, [inaudible] S equal to that. So, this is a type of conversion that's possible. So, it's easy to do. So, you just use this int32 function to do it. Note that there are other type of conversions that you can't do so easily, and it will fail on those, but some of them are possible, like this one. So, another type, besides integers, are floating points. So, floating points, they're basic real numbers. Now, depending on how many bits long the floating point is, say, you got float32, that's going to give you approximately six decimal bit digits of precision. Float64 is going to give you approximately 15 decimal digits of precision. So, you figure out how many bits you want to use, how big you want it to be based on how much precision you need. Often, it tends to be, you want to go longer than shorter because precision errors are a common problem in floating point arithmetic, so you want to use more precision. The more precision is probably the better. Of course, there's a space issue. You use more memory if you make them longer, and also, performance changes. But still, precision errors are an issue sometimes. So, you can express floating point numbers with decimals or in scientific notation. So, we can see two, var X is float64, 123.45. That's a decimal. It'll make it a floating point representation. Also, you can represent the same thing scientifically with this E as the exponent for the 10. So, this is base 10. So, E2 means 10 to the two. Also, you can represent complex numbers. If you want to, they have complex numbers. So, if you remember complex numbers from high school or wherever you learned it, you get the real part and the imaginary part. So, this is how you create a complex number. You use this complex function. You give two arguments. The first number is the real, the second number is the imaginary. So, two plus three I would be that complex number, if you're using complex. So, first, we are going to talk about strings. In order to talk about strings, we need to talk about ASCII code and Unicode. So, strings are going to be sequences of bytes. We'll see that in the next slide, but each individual element, each byte in a string, strings are made to represent different characters that you see. So, often, strings are made for printing. They don't have to be for printing, but they're often made to represent printed things. So, for instance, the string hello world, that's something that's meant to be printed and seen by a user. So, now, each one these characters that you want to store in a string, each character has to be coded according to a standardized code. ASCII was basically the first accepted one, American Standard Code for Information Exchange, and it's just a character coding. So, each character that you want to represent is represented with an 8-bit code. So, for instance, a capital A. Capital A in ASCII is the number 41 in hexadecimal. I just know that. I tell my head it's a common code. But it's 41 in hexadecimal. So, that's an 8-bit code. So, ASCII is an 8-bit long code, which means it can maximum represent 256 possible characters. Really does 128 because one of the bits is used for something else. So, that's not a lot of characters. So, an 8-bit code is sufficient for English because they aren't that many letters in the alphabet. But once you start incorporating other characters that you need to include, so, for instance, Chinese is a good example because there are a lot of characters in Chinese, you can't use an 8-bit code and hope to represent Chinese. So, once you start trying to look at all these different character sets in different languages and different characters that maybe even aren't part of languages but things that you want to represent anyway, that you want to show and have appear on the screen, you need a lot more than 8-bits. So, that's what Unicode is for. Unicode is a character code that is a 32-bit long code. So, you can represent two to the 32, which is a lot bigger, two gig, I think. So, it's a lot bigger. So, that's a lot of characters. Now, UTF-8 is, say, a subset of Unicode. It's a variable length code. So, it can be 8-bit, but it can go up to 32-bit. The first set of codes in UTF-8 match ASCII. So, all the ASCII code values are the same as their UTF-8 values. So, for instance, capital A, it's in hexadecimals of 41 in ASCII. It's also a 41 in UTF-8. Now, UTF-8 also includes a lot of other codes like, for instance, Chinese characters. Those aren't in the first 128, they're outside of that. They require more bytes. You can't just use an 8-bit code to represent those or maybe those of 16-bits or 32-bits. So, UTF-8 is a variable length code, but it represents a lot more characters than you can represent with ASCII. Now, the default in Go is UTF-8. In UTF-8 or Unicode, code point is a term for a Unicode character. So, there can be up to two to the 32 code points. In Go, they call a code point a rune. So, rune is just a term for a code point. So, the capital A character, it has a rune, which is represented with 0x41. In hexadecimals, it's a 41. You call that it's rune. Now to strings. Now, strings are arbitrary sequences of bytes represented in UTF-8. So, each byte is a rune represented as a UTF-8 code point. So, the strings, they're read only. You can't modify a string. You can make a new string that is a modified version of an existing string, but you can't modify an existing string. Often meant to be printed or displayed to a user. String literal is just a string that's notated with double quotes. So, for instance, if I say, X colon equals hi there, that's a string literal. That's a sequence of bytes. Each one those characters, H, I, space, T, H, E, R, E, each one of those is going to be represented as a rune, a UTF-8 code point, and they're put together. An array of those, we'll cover arrays soon, but an array of those is going to be a string.

# M2.2.3 - String Packages
So we've already talked about strings. Strings are a common construct. You see them in every programming language, and strings are made of unicode Unicode runes. They're straight, basically, a raid of runes. So, there's a package called the Unicode Package which provides a set of functions that actually evaluate the properties of the different runes inside the strings. And it's useful if you've ever done parsing, you know, you want to parse some string out of whatever file. Or out of a- maybe something somebody typed in directly as user input and you want to evaluate that string when you're doing parsing you need functions like these so there a long set of functions that the unicode package provides to evaluate the runes Some of them here, are IsDigit tells you if the rune is a digit, a numerical digit. IsSpace- is it a space character? isLetter is the letter lowercase, IsPunct- is punctuation so these are all binary- boolean right so they return true or false depending on if the rune is what it's saying it to be, if it's a digit or space or so on.
Play video starting at :1:18 and follow transcript1:18
There aree also a set of other functions that perform conversions. So some of these conversions ae possible. For isntance ToUpper and ToLower. You can take a lower case (r rune),turn it into an upper case (r rune). And vice versa. So they provide funtions for that. So they take a (r rune), like ToUpper, it takes a (r rune), Which is lowercase and returns a which is uppercase and so on. So a unicode package is useful for that. But there are other packages that are also involved in manipulating strings. There's the strings package. So the strings package. The functions that it provides are things to directly. Not looking at the individual generally, but look at the whole string. So there are a set of search functions it provided. Inside the strings package. These are common functions that you see in lots of different lanugages also. So for instance, the first one would be compare. Compare (a, b), you givev it two strings and it compares to see if they're equal. And actually this compare function, it returns a -1. It returns 0 if they're equal, it returns a -1 if a is less than b, meaning earlier than it, in In alphanumeric order. And A, it returns a positive one, if A is greater than B, so if A is later than B in alphanumeric order. So, to compare, contains, so you give S a string, and then a sub string, if that sub string is contained inside S, it returns true, otherwise false. Have prefix so you give it a string s and a prefix. If that and returns true, if that prefix is the, s starts with a prefix and index s and you go to substring, what that does is a search, it searches for the substring inside s. And it returns you the index of where the first instance, instance of that substring can be found inside a [INAUDIBLE] can be found. So, this is the string's package. Now, the string's package also provides a set of functions that manipulate strings. Now, when I say manipulate, you can say changes string, a string is mutable. But, there are a lot of functions that take an existing string and return a new string. That is some modified and some useful way. So the first one will be replace. With replace you basically take a string and it allows you to replace instances whenever it finds it in a current of old it replaces it with currents of new. So these are all strings. So there's a big string S Is a substring old and another substring new. Replaces instances of old with instances of new. And return to a new string. So s the original string is not actually changed. It returns you to a new string with a replacements for ToLower, ToUpper, so this'll take the whole string and change it to lower case or upper case. I keep saying change. It does not change the string. It returns a new string that is modified. Also, trim space is useful. That gets rid of leading and trailing light space from a string. So you get this a lot when you're reading from a file with, say, and maybe the tokens in the file are seperatedby spaces, so if you just read directly in the file, you'll also read these spaces in, but you don't need the spaces. You just need the token. So you may call TrimSpace to get rid of the spaces.
Play video starting at :4:22 and follow transcript4:22
Another package that has a lot of useful functions for strings is the Strconv Package. So generally this provides a set of functions for converting strings
Play video starting at :4:34 and follow transcript4:34
from different basic data types, to and from different basic data types. So some of the big ones are Atoi As ascii to integer is what it stands for. And converts a string to an integer if that string represents an integar.
Play video starting at :4:48 and follow transcript4:48
Lets say, you are reading a string from a file and the string is a number 123 one hundred and twenty three. Now when you read that, and you read that as a string, You can't do math on a string, right? You can't take that 123 and add 1 to it because it's a string type, it's not an Int type. So you need to read that string in and convert it to an Int. And then you can do math on it. So you'd use Atoi to do a thing like that. And Itoa does the reverse. It converts an Int into a string, an equivalent string.
Play video starting at :5:19 and follow transcript5:19
Then FormatFloat basically does a similar thing for float. So it converts a floating point number into a string representation of that floating point number. And then ParseFloat does the opposite, converts a string to a floating point number. So a string, so if you have a string. 123.45, and in a string it can convert it into a floating point the number you can actually do method.

# M2.3.1 - Constants
So, let's talk a little bit about a constant. So, constant it's pretty obvious what the constant is. It is an expression whose value is known at compile time. Right. So, you know it and it never changes. So, you can just basically declare a variable to be a certain value and it holds that value for all the time, as long as the program is running. The type is inferred from the righthand side of the assignment. So, for instance, here we say const x equals 1.3. So, that's going to set x to the value 1.3 and the compiler looks at 1.3, sees that that's a floating point and so x becomes a floating point. So, it infers from the right hand side of the assignment what the type of the variable needs to be and it is held constant, can't be changed. You can assign many at once. So, constant we have y equals four, z equals hi. Alright. You can give a long list if you want to. So, that's what a constant is. Now, iota is a function used to generate constants. It's interesting. So, it generates a set of related but distinct constants. So, when do you use this? You use this when you have to represent some property or some property that has several different distinct possible value. So, this is also known as one-hot. So, basically if you have a variable and you know it's going to be one-hot coded. Right. This variable can have one to five values let's say. So, you want each one of these five values to be a distinct constant. Right. Now, in a situation like this, just examples of such things, days of the week. Right. You got seven days of the week and you want each day of the week. If you want to define a constant for each day of the week, Monday, Tuesday, Wednesday, you want them all to be constants which are different but which are different and you don't particularly care what the value of the constant is, as long as Monday is different from Tuesday which is different from Wednesday. Months of the year same thing. Right. So, key thing about these constants is, when you use iota to generate these constants, the constants need to be different but the actual value of the constants is not important. So, if I have Monday, Tuesday Wednesday as my constants, I don't care if Monday is 500 or 5,000 or two or something. As long as Monday is not the same as Tuesday, which is not the same as Wednesday. Right. So, that's the case where you can use iota. If that's the case, you need to represent some set of constants with all different values, you don't care exactly what the value is but as long as they are distinct constants then you can use iota. This is essentially just like an enumerated type in other languages like C or something like that. It's the same idea. So, they give you a nice little shorthand for defining these set of constants. So, here's a little example of how you might define something using iota. Say I wanted to find some grades. So, I make a type called grades. I make it an int. I want to represent my grades as integers. I want to have these five grades A, B, C, D and F. I know that I want A, B, C, D and F to be all different grades. Right. So, they should be represented by different integers. But, I don't particularly care what integers they are represented by. I just want A to be something different than B and C and D and F. So, I declare the constants A, B, C, D and F. The first one, I say A give the type grades. Right. Which is actually an int, alias for int. A grades equal iota. I say that in the first constant definition. Then for B, C, D and F, I don't have to repeat that. Right. You can see I just say B, C, D and F. I don't give the type, I don't say iota, none of that. They just do it on the top and what will happen is automatically iota will assign a value to the first constant and then it will assign a different one to the next one, a different one to the next and so on. Actually, what it does what the implementation does is that, it assign it starts at one. So, A would be one, B would be two, C will be three, but you should not depend on that. Right. That's not. So, you don't know the idea behind using iota is it, you don't care what the actual values of the constants are. You just want the constant values to be different from one another. So, it happens that the current implementation starts off at one in increments, but you can't guarantee that in the future maybe that's going to be changed. Right. Just all you know that iota is that they're going to be different.

# M2.3.2 - Control Flow
[MUSIC] So, Control Flow describes the order in which statements are executed inside a program. Now, basic control flow, the most basic control flow is just executing one statement at a time, one after the other, right. A procedural control flow, just top-down.
Play video starting at ::27 and follow transcript0:27
Now, the control flow changes for a lot of reasons. But the first reason why control flow changes is because the programmer inserts control flow structures into their code, which changes the sequence in which the statements are executed. So the main control flow structure, the first one, is an if statement. Basically, with an if statement, you can conditionally execute certain sequences of code. So if this condition is true, then you execute the sequence of code. If not, then you don't. And this, what we're showing here, is the most straight forward if statement without an else clause, you can also have an else clause, but I'll just start with the basic one first. So the structure is just if, condition, you write some condition in there, x is greater than 5, or something like that, and this condition has to evaluate to a boolean, right. If that condition is true, then whatever is inside the curly brackets, label consequent there, that's executed. And you can have any number of statements inside there, and that'll be executed if the condition evaluates to true. So this changes control flow because instead of just definitely executing the next statement one after the other, it checks its conditions. If the condition's false, then that consequent, those statements in the consequent are not executed at all. And so, we can see at the bottom, we got, if x is greater than five. And then it prints, it performs a print state. And if it's not, then it just skips that entirely. Now, this if statement, this is a very vanilla if statement. You could also have an else clause after that, right? So if the condition's true, it executes what's inside the curly brackets. Then, you could have a next clause, the else clause. It would execute whatever's inside the next set of curly brackets, the next block for the else, right? We didn't include one here, but this is a straightforward extension. And you see this in every major language.
Play video starting at :2:11 and follow transcript2:11
So for loops, they're another form of control flow statement.
Play video starting at :2:17 and follow transcript2:17
Again, so for loops, what they do, basically, they're loops. So the control flow, rather than just going top-down, when you hit the bottom of the loop, you come back to the top of the loop, and you do it again and again until a certain condition is met or not met. So that's how they alter control flow. It's just, and these are extremely common in programming, using loops. So, they just iterate over a block of code, as long as the condition is true. Now, there's several forms of for statements, we're looking at one right here. Probably the main and most common form. You see it similarly in C and things like this. If you look at that keyword for, right after that, there are three statements, really. There's the initialization statement, init. There's a condition, and there's the update. And separated by semicolons. So the init is executed once at the beginning of the loop. So, the first time you hit the for loop, it executes the init just to initialize things, right at the top. Then, the next block, that condition, that is checked on each iteration. So at the beginning of each iteration, that condition is checked. It has to result, it has to be an expression, that results to a boolean. If that condition is true, then it executes all the statements inside the loop. Otherwise it doesn't, otherwise it's done with the loop, and it continues past the loop. So that condition is the termination condition. It determines when you stop executing this loop. because as soon as that condition is not true, you skip the loop and you're done. Now, the update, that third block there, the update is what is executed at the end of each iteration, and it's used to act as some element of a state. So a very common way in which you use is you'll have, you'll have some index variable for i. i equals zero, maybe start off with i equals zero, and you want to do this, iterate through this ten times, so the condition might say, i less than 10 and then the update would be i++, or i=i+1, right? And then every time, every pass through it updates that i value, that element to the state. And one thing about these for loops is, unless you want an infinite for loop which you typically do not want, you gotta make sure that that condition is, at some point, false, right? because if the condition is always true, then you never leave the loop. So the most common way to make sure that condition's always false is to make sure that update changes the state in such a way that eventually the updates cause the condition to be false. So for instance, if I say i is equal to zero, I start off being equal to zero, and my update is i equals i+1, then eventually i will be greater than 10, so the update guarantees that the condition is eventually false, and that you eventually drop out of the loop. So here are some forms of for loops, these are three most common forms of for loops. The top one is what we've already seen. You've got the initialization, you got the condition you got the update. The next one, if you look at the for keyword, there's only the condition check after it. No initialization, no update. You don't have to have those. Now, instead, what we did here to make it equivalent to the for loop before, we had to put the initialization before the for loop, that's another way of doing it. And the update is now built into the for loop, so if you look, there's an i plus plus inside the loop, right. So, it's actually inside the fourth block, instead of, as you have in the first form, where you actually put it in there right after the keyword.
Play video starting at :5:46 and follow transcript5:46
But, it's another way you can define a for, which is really just like a while loop inside another language. Then, the last form is just an infinite loop.
Play video starting at :5:55 and follow transcript5:55
It has nothing after the for loop, it just is an infinite loop, which is not typically what we are going to be doing. You do that, maybe, in an embedded system but, it's not common to do in a regular program. You usually don't want an infinite loop.
Play video starting at :6:8 and follow transcript6:08
All right, so another type of controlled flow is a switch.
Play video starting at :6:12 and follow transcript6:12
Switch is paired with case, right? So a switch is a multi-way if statement. So, you often get situations where you want to say, if this is true you do this. If this is true, you do that. If this is true, you do that. You sort of, you do one of a set of cases. Sort of an else if, if else if is another way to write this type of thing. So a switch is like, there's a set of cases and only one of them is going to be executed. Whichever one matches. So the switch may contain, typically contains, a tag, which is a variable to be checked. Right, so maybe I say switch x. So that's the variable I'm going to check. Then each case is associated with some constant value that x is compared to, that the tag is compared to. So tag is compared to the constant defined right after the case keyword. And then whichever case is constant, matches the value of X, that's the case that's executed, and none of the rest are. So, in this example, you can see, you got switch x. Inside you've got two cases. Case one, case two. So if x is a 1, it will execute case one. If x is a 2, it will execute case two. And then the bottom one is default. Default is executed if none of the cases are hit. So it's an optional thing. You don't have to have a default. But you can have it default so if it falls through, it'll end up executing something. So this is a typical form for a case. And one thing to note, just if you're used to C, is in comparison to C, the case automatically breaks at the end of the case. So in C, If you were to execute case1, say x was equal to one, you hit case1, you execute case1, it would also follow through and execute case2, right? That's what C would do, unless you put a break statement in there at the end of case1, right? After the fmt.Printf, you put a break statement, then it would skip the other case in the default. In switch in Go lang, you don't have to do that, it automatically breaks, which is a good, good thing.

# M2.3.3 - Control Flow, Scan
To continue with the control flow, we were looking at switch. Let's talk about a Tagless switch. This is a variant on the regular switch. So, normal switches, they have a tag, switch X let's say, and that's the tag, that X, and that's a variable that's going to be compared to constants that are right after the cases. So case one, case two, case three, X as compared to those constants one, two and three. So, sometimes, that's not what you want. Sometimes, you can have a switch without a tag. And when you do that, then what happens is the case that X it gets executed is the first case whose expression is true. So what I mean by this is, when you don't have a tag in the switch, then each case is going to have to have it. Instead of having a constant after, it will have some expression that resolves to a Boolean, true or false. And if that Boolean is true, then that's the case it's executed and it'll execute the first case whose condition is actually true. So, here's an example of that, in this case we have a switch, there's no tag. We just have these cases, two cases plus a default. So, case X greater than one, case X less than negative one and then default. So, in this situation, since there's no tag, it just looks to the right of the case keyword, looks the condition, X greater than one, evaluates that. If it's true, then that's the case it gets executed and we're done to switch. If it's false, it goes and checks the next case to see if this condition is true, and so on until you're done with all your cases. And then if none of them happen, then the default is executed if you've included a default. So that's the tagless switch, and you can use that as well. Instead of if else, if else if, you'd use a switch like this, tagless switch. Break and continue were also control flow instructions. Sometimes the're considered bad form, but they definitely exist and they're used. So, break and continual for loops. So, a break exits the containing loop. So say you're inside a loop and that loop, in this case we got a four loop and i equals 0, i less than ten, and there's an i plus plus inside the loop. So, this is supposed to happen, whatever this is, it's supposed to iterate through ten times conceivably. But notice inside the loop, it says if X equal, equal five then break. So, if it hits that break, and it will in this case, when it hits that break, it will exit the loop. So, this thing only execute for i equals zero, one, two, three, four, and five. It'll go into the loop and it'll hit the break on the fifth pass through the loop, so it won't finish the loop. So, break just jumps out of whatever the containing loop is and quits the loop. Now continue on the other hand, it also uses loops. It doesn't quit you out of the loop, it just skips the current iteration of the loop. So, if we look at the continue example, same code, except instead of a break, it calls the continue. If i equal equal five, then it calls continue. So, in this case, if without that if statement and that continue, it would execute this loop 10 times, because i starts at zero, it goes up to the condition i less than less than 10. So, it would execute 10 times. But for this loop, it says if i equal equal five continue, so that one iteration where i is equal to five, it will continue and just jump right past that iteration of the loop. So the loop will execute, but it won't execute as many times. It'll skip one iteration of the loop. So, scan is a function to read the user's input. This isn't a control-flow function, but we need to hit this because read user input is something that you're going to use in the code examples that you write. Sort of a common thing to do, you want to read input that the user types into the keyboard. So, this isn't the format package. What scan does is it takes a pointer as an argument. So, what you do is you make a pointed to some value that you expect the user to type in. So, if a user is going to type in an integer, you'd make an integer and you would pass a pointer to that integer to the scan function. You call Scan, and when you execute the scan function, it blocks. The program waits until the user types in something and hits Enter. When they hit Enter, the scan function will take whatever they typed in and will place it wherever the pointer is pointing. So, it will take what they typed in and put it into say an integer. If you pass the pointer to an integer, it will take it, turned to an integer point in, put it into that integer. And what it returns is the number of scanned items. It returns actually two things; the number of scanned items, the number of tokens that a person typed in. So, space separate tokens that's returned, also an error. The second thing is returned as an error. If there's an error, it'll return something other than nil. If there's no error, it'll just return nil for that error. But if there's an error, it'll return an error code and we could investigate that. So, we can look at this example code. Let's say, we make a variable appleNum and it's an integer. Then we print out number of apples, question expecting the user to type in how many apples. So, we expect them to type in some integer, five, let's say. So, the next line, it executes the scan function. The code will actually stop running there and wait until the user types in something and hits Enter. So, let's say the user types in a five hits enter. Then notice that the argument to scan the argument pass is ampersand appleNum, which means the address of the AppleNum variable. So, when the user types in five and hits enter, that scan function takes that number five, puts it into the appleNum variable. So on the next line, when I say, printf appleNum, it'll print five or whatever integer they typed in.