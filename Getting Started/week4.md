# M4.1.1 - RFCs
So, an RFC is a request for comments. That's technically what it means, but what it really is is a definition of a protocol or format, a standard definition. Now, reason why we're concerned with these they're not part of goaling directly, but whenever you write a big program, you'll to do something, you going to want to interact with other systems, other blocks of data somehow. I mean it is extremely common. So, for instance, maybe you want your program to read files, read database files and process them, right? So, these database files they maybe they came from some other source, some data maybe somebody inserted them on the web add edits MySQL database and you want to be able to read those files, right? So, there's got to be some format that everybody agrees on, that you can communicate through. So, this is going to be in this particular format and your code can process that format. Same thing goes for maybe it's a network protocol, right? So, maybe your machine, maybe you want to do client server thing, right? So, you want to make a web client. Your web client needs to talk to a server over the network. In order to talk to a server, it's got to send messages in with that adhere to a particular protocol. So, the server understands what it's getting. Then, on the other end on the receiving end your machine, your program has to be able to understand the format, the protocol of the message that it receives in return, right? So, whenever you make some a bigger system and it needs to interact with other systems, through data transfer. This data has to be formatted in a way that everybody understands it. Say so, there are many of these formats and protocols that are well-defined and are standardized and used for communication and trading data between different systems. There are many of them. RFCs are the name that are used for these protocol a lot of these standards. They're not RPC-based standards but RFC's are a broad swath of standards. So, for instance, let's give you some examples. Take HTML, HyperText Markup Language. HTML is the language in which web pages are written. So, it's a standardized language actually is RFC. I got the RFC number right there on the slide. It's a standardized language so that all clients, all web browsers they have to understand this language so they know how to render it on the screen and so on. So, that's one of those languages to standardize and you can trade data between a client and a server, between a web client web server using this standard. Also URIs, right? These are also there it's an RFC too. URI stands for a Uniform Resource Identifier. It's basically the addressing method use on the web, right? So, you've heard of a URL this type of URI. So, there's a particular format and the way that it's supposed to see and that it's got to adhere to a particular format so that every client, every server can interpret the address. HTTP, that's a network protocol web page web network protocol defines the web. Hypertext Transfer Protocol, okay? That's RFC 2616 and that describes how the messages should be transferred on the network. So, what information should be included each message and what the headers are. Where the data should be. The content and so on and the lengths stuff like this. That's all defined so that a client can talk to a server, web browser can talk to a web server or something like that. So, these are just a few of the protocols of the standard protocols that are defined by RFCs. They're a lot more and these protocols can be arbitrarily complicated some of them, right? Some of them are simple, some of them are complicated. So, what happens in Golang arrives was like Golang they provide packages that help you to process these formats, a lot of these not all but a lot. So, there are packages for most of the important RFCs, there are packages already built that you can incorporate you can import into your program. So, and these packages they provide a set of functions that you use to encode data into the into whatever the protocol is the format is and also to decode, right? So, if you're receiving something in a particular format from some other source you need to decode that information into structures. Maybe structures, or maps, or some Golang objects, right? The other an encoding is the other direction where you take some go objects and you convert them into this common protocol or format. So, as an example there is a Net/HTTP. That's where that's where HTTP, HyperText Transfer Protocol and they you have that package and it provides a bunch of functions in there that allow you to make to make messages and send them. So, for instance, I've got this example Http.get, that makes a get message you pass it as an argument a web domain and it will make a request to that domain for a web page and it'll return the actual content of the webpage for you, right? So, there are a set of functions like that defined in this package that allow you to communicate over the web, right? Send, so, if you want to make a web client or the web browser web server or something like that you'd use a package like this. Another package a more basic one is the net package and this is for TCP/IP and socket programming. So, this is a long description but TCP/IP basically define the internet. So, Internet you can do web-based communication on the Internet but you can do all communication protocols on the internet FTP, Secure Shell, is a whole list. But, all of them share in common is basic TCP/IP, UDP stack. Set of protocols that they all have to adhere to. So, the net package gives you a set of functions that allow you to use that protocol. So, for instance, this example here net.Dial TCP says, look I want to make a TCP connection and you give it the domain uci.edu:80 tells you the port number, you pass that and it made it establishes a communication or connection Internet connection, TCP connection specifically with uci.edu on that particular port which happens to be a web port but, so, there are a lot of these packages that are used to support to make it easy for you as a programmer, to use these different protocols, communication protocols and data formats that are commonly used by different systems. It's just a very useful thing to have these packages and to use them. Because when you don't have them you have to do it from scratch, meaning you have to. For instance, take HTTP, if I didn't have the HTTP package, I would have to understand everything about HTTP and make the packages on my own. I have to basically make the message format in my own. I have to write my own code to do that. Now, this is not impossible but it is time-consuming why do that when you can call Http.Get it makes it a lot easier for you as a program. So, JSON is one of these protocols is a, is not a protocol it's a data format, commonly used data format across the world and we're going to talk about that and the package associated with it. So JSON stands for JavaScript Object Notation. We are not programming in JavaScript but JSON is bigger than JavaScript. Now, JSON is just widely accepted as a common way to represent structured data. It's RFC 759, it's a format to capture structured data and unstructured data, I mean a set of attribute value pairs. So, this is a natural for a struct or a map, right? Because if you remember structs, they have key they have no keys they don't call them keys. They have fields and values of the fields, right? So, a field value pair, could be an attribute value pair and JSON. Or a map has key value pairs, right? That's the same that can easily be an attribute value pair. So, these attribute value pairs and JSON naturally map. Naturally, no I shouldn't use the word map, they naturally correlate to strucks and maps inside go line. Now, the keys and values or rather attributes and values as they're called in JSON, they can be basic value types. So, you can take Bool, number, strings, arrays, objects and they can be combined hierarchically. So, it's easier if we see some examples of this. So, let's take an example of a startup with a Go structure, right? A Go struct, the person struck that we had before, right? So, this perfect person structure I'm making P1. I'm saying P1's person with a name of Joe, address of a street and a phone number, 123. So, that information maybe we if they want to transfer it to another machine somewhere else, okay? We're going to give it to somebody. So, we want to take it from right now we have represented as a structure in Go. We want to represent in this common JSON format. So, that somebody else, some other program, some other system somewhere can interpret that. So, what we're shown below is the equivalent JSON object. So, up above you see the struct as we would define it in Go. In JSON, what it would look like as a JSON object is shown right there. Notice this is very similar to the structure to what a struct looks like or what a map looks like. It's basically name: Joe. Address: street. Phone: 123. Now, one thing to note is that the name, their field names, the attribute names, name, address, phone, they're in quotes, right? Which they weren't when we define the Go structure, we didn't put them in quotes. So, it's a little bit of difference but notice that it looks very similar to the struct, right? So, that JSON object we can take that and pass that on to some other machine, some of the program and if they can interpret JSON, then they can extract all the information that we were using in our program about this person. This is of course one person but I can have a database full of people. I could just make a set of JSON objects pass to somebody and they could read this database full of people. So, this is just a simple example of JSON. But, JSON is actually nice and it's a good format, it's well accepted.

# M4.1.2 - JSON
So JSON as a format has several properties that are advantageous, one is that it's all Unicode, okay? So any JSON object, once you convert something into JSON, it's going to be represented all as Unicode characters, which is good because Unicode is understandable by people. In fact, that leads to another thing, it's generally human-readable, right? It's a human could look at the JSON format and understand, for the most part, what it is. It might be slightly complicated, but it's readable by a human. Now it's also a fairly compact representation. I say fairly compact, because it's not completely compact, if it were the most compact, then it wouldn't be human readable anymore. So if you took the JSON object and just compressed it, you would get something that was smaller, but you couldn't read it, okay? So it's fairly compact. It's human readable, it's as small as you're going to get and still be human readable, put it like that. So, the types inside JSON can be combined recursively. When I say the types, the different types of data that you're putting together. So, remember that in JSON we're going to want to represent these different data structures that we have, these objects that we have in Golang, we're going to want to represent them as JSON objects. So they can be combined recursively. So you can have an array of integers or an array of structures or a structure with structures inside or a structure with arrays inside and integers and strings. So you can combine them all heirarchively, right? A structure with structures inside which have other structures inside and so on So you can get arbitrarily complex golang objects and convert them into JSON, so that's a pretty good advantage.
Play video starting at :1:58 and follow transcript1:58
So JSON marshalling, marshalling, the term marshalling, means to, and in this case, in JSON marshalling, you're generating JSON, a JSON representation from an object, in our case a go object, right? So we've got some object arbitrarily complex in go, we want to turn it into something that adheres to JSON format, right? So that's called marshalling, JSON marshalling. So in this example, we're going to start off with our person struct, and here's the general structure. Type struct's got a name, address, phone, they're all strings and this is the structure. So let's say we create, we have an actual person, an object of this particular structure of this type. And this person, p1, it has a particular name, joe, address, a st., phone, 123, we've seen this before. So now we want to take this person, destruct, and we want to make it, turn it into a JSON object. So we call this function JSON Marshal, json.Marshal.
Play video starting at :2:55 and follow transcript2:55
And notice if we pass this as an argument, we pass p1. The golang structure that we want to convert, we pass that as an argument to JSON Marshal and it returns two things. In this case, the first thing is B array, I'm calling it next as error. So the error it's a nil if there's no error. If it converts properly, then there should be a nil. There will be no error and what it returns is B array It's actually going to be a byte array which contains the JSON representation. Remember that JSON is all in unicode, so this byte array is a bunch of ruins, basically, an array of them, and that is the JSON representation. So, what json.Marshal does is it takes a golang object, returns you a JSON representation.
Play video starting at :3:42 and follow transcript3:42
So JSON unmarshalling is going in the opposite direction. What you're trying to do is you take some byte array which contains a JSON object, and you want to convert that into a golang object, right, which store the same information. So going from the last slide, we're again talking about this person struct. So let's say we have already made our barr, our B array, and that's a person, okay? It's a JSON representation of a person. Now we want to Unmarshal it, so we want to take this JSON representation and create a Golang struct which contains the same information. So what we do is we declare that golang struct. Up at the top we say var p2, we'll call it p2, person. So it's a person but we haven't created it yet, we haven't filled in the name, address, phone yet. So we just have a person and it's basically empty, then we call json.unmarshall. Now notice there are two arguments for pass onto json.Unmarshall. First argument is, the B array, which is the actual byte array, which contains the JSON object. The second argument is the address of the Go structure, that we want the results to be placed into. So, address of p2. because remember that this b array contains information about a person, we want that to be put into this p2 that we've created, that is, as of now, empty.
Play video starting at :5:3 and follow transcript5:03
So when you call it it just basically unpacks the v array and puts the attribute values into the appropriate fields of the person structure p2.
Play video starting at :5:15 and follow transcript5:15
Now, one constraint is that this p2, whatever the second argument is to Unmarshal, it needs to fit the JSON data, the JSON byte array. When I say fit, I mean the JSON object is going to have a set of attributes and values of those attributes. P2 Second arguement, it's got to have the same attributes, so if it's a struct in this case, it's gotta have, those have to be the field name. So if the JSON object has an attribute called name, then the Goliang object P2, it better have a field called name, right? So that's the idea, so it has to fit. But if it does, then what will happen if you call unmarshall and then in the end P2 will contain, will be a struct with all the information that was contained in the JSON object. And that error value that is returned by json.Unmarshal is nil if everything works, if everything fits. If it doesn't fit, it will throw an error. Thank you.

# M4.2.1 - File Access, ioutil
So, files are very commonly used in programs and used to trade data between programs. So, we're going to talk about how Golang allows us to access files. We'll give an overview anyway. Now, file access, and this is true in all languages, file access is linear access, not random access. So, the reason for this is because files, when they were originally defined, they were actually stored on tapes, right? Physical tapes. When you access a tape, you remember, it depends how old. But I used to have cassette tapes. Or big old tapes, you see them in movies, science fiction movies, big old tapes, right? They turn this physical tape that is on as linear access. Meaning, the beginning of the file is at one point of the tape, the end of the file is way over here at the other point of the tape. So, if you want to access it, you got to start, you read one point of the tape, and you got to turn the tape and read the next point. Turn the tape, read the next point, and so on. So, it's always linear access. Wherever the turning limits it. This is mechanical operation of physically turning the tape to access the next piece of the file, right?. So, it's always linear access. If you want to just access something at the beginning then something at the end, that would waste a lot of time. The beginning is here, then you've got to take a lot of time turning to get to the end, right? Instead, you read it linearly. You'll say, ''Okay, I'm at the beginning and I read everything in that vicinity.'' You read from the beginning to the end. So, that's how file access still is today. Even though, you don't necessarily have this linear access constraint. I mean, if you look at physical disks, they still have linear access, right? There's still tracks, and you have to go through the whole track. So, there's still some linear access in that, but for all we know a file might be in a random access device. So, for instance a flash memory or something like that, solid-state drive, right? That's actually a random access device, but still the way that we access files in programs is as if it's a linear access device. So, normally when you access files, you get in other languages too, you get this set of basic operations that are common for file access. So, first one is open. It's getting a handle tests start accessing the file, you have to open the file first. Then you always get a read function or some variety of read functions, where you can read bytes from the file and read them into like say a byte array. Write, where you write data from a byte array and move that into a file. Close, is when you're done, you close the file because you're done reading it or accessing it. Then seek, is another thing, a common thing to have. Seek basically moves your read head. So, what that means is it's linear access, right? So, you read from the beginning to the end, but sometimes you really do need to skip to a certain point and seek does that. So, these are very common functions that you see basically in any language to access files. So, there's more than one package in Go, that allows you to access files. It has functions in it that allow file access. We'll start with the ioutil package. ioutil package has some basic file access functions. Basic, they're easy, they're nice to use. If the basics are enough for you, ioutil is great. So, the first function you get there is a ReadFile. Now ReadFile, you'll notice it ioutil.ReadFile, it takes as an argument the name of the file you want to read. That can arbitrary test.txt or whatever you want to call it. It returns two things, data basically byte array, and then an e is the error, so it returns two things. An error is only if there's some error reading but if there isn't an error, its main job is to return this byte array, which is the first thing that it returns. So, what it does is pretty simple. It just reads the whole file and returns the contents of the whole file into a byte array, and then you can manipulate the byte array. Now, when you use ReadFile, you don't have to do an explicit open or close. You don't have to open the file at the beginning, close it at the end. That's all built into the ReadFile function. So, it will just open the file, read the whole thing, and then close it. So, it's nice. One issue with it is that large files can be an issue. So, when I say it cause a problem, it's not going to cause an error, but files can be gigantic. Okay. I mean, if you think about the size of a disk, the disk can be terabytes, right? I mean, I have a terabyte disk in my machine, right? That's normal, right? So, you can have giant size files. You can have files that really take up most of your memory. Because when you read a file, it takes it off of whatever the storage devices, let's assume you are using disk for a second, okay. Say, I put it on disk, but it could be solid-state storage too. It takes it, and it reads it into RAM, into its main memory. Now, main memory is much more limited. So, my disk, I might have a couple of terabytes, but my RAM I might only have eight gigabytes. So, I could have a file at eight gigabyte long file in my disk, that I tried to read into main memory. If I read that whole file, I'm using up my whole RAM and my machine will choke. I can't run anything because I've used up all my memory. So, when you have large files, ReadFile you can't use it. But if your files are small enough so that it doesn't hog up all the memory, then ReadFile is fine. You can just read the whole thing in at once. Now, ioutil also has a WriteFile function which is complementary to the ReadFile and if you look at WriteFile, it takes, let's say it just takes three arguments. First argument, is the name of the file you're going to write to. The second argument, is the byte array or as a string and then the third argument, is the permission. So, remember WriteFile, is actually creating a new file. So, when I call WriteFile here, I'm going to create a new file called outfile.txt, and it's going to write the data ''Hello, World'' into that file. When it creates that file, it has to give that file permissions, read and write access permissions. So, it's using unix-style permission bytes. So, seven, seven, seven means permission for everybody. Everybody can do everything. But, you can adjust the permissions that you see fit, but those are the arguments to WriteFile. So again, it writes. Now remember WriteFile is not flexible. You can append to a file or something, you can't say, ''Oh! Let me just add onto the file.'' WriteFile, it just creates a file, dumps everything, the whole string, or the whole byte array into that file, and then closes the file.

# M4.2.2 - File Access, os
So, when you access the files, we talked about the IOUtil, it gives you some simple functions. But if you want to have a little bit more precise control over file access, then you're probably going to use the OS Package. The OS Package provides a bunch of functions to access files too and you have more control. So, with IOUtil you could read the whole file and write the whole file, who knows about it. With OS Package you can do a little bit more, read a little bit, write a little bit, do different things. So, here are some of the functions in there. First, you've got os.Open that opens a file. So, you pass it the name of the file and it'll return a file descriptor. A file struck basically, I'll call it F, let's say. It will turn a file descriptor that you can use to access the file. Now, os.Close, it closes the file when you're done. Os.Read reads from a file into a byte array. Okay? Now, and it reads to fill the byte array. So, you can control how much you read unlike with read file IOUtil you had to read the whole file. If you only want to read ten bytes out of it, you can make a byte array of size 10, and pass that to read, and read will fill that byte. So, read 10 out. Read however how much you need to fill the byte array. Write is a similar thing. You can take a byte array and write that into a file and it'll just right as much as the byte array is long. So, here's an example of a file reading using the OS Package. So, first thing we do is we open the file. So, we call os.Open, pass it the name of the file which is completely arbitrary. So, we pass this file dt.txt. It opens it. It returns this F, this file handle that we can use to access the file. If there's an error like the file doesn't exist, it's something like that, then it'll throw an error, but otherwise it'll return this file handle. Now, for this file I want to read, right? I want to read into some byte array. So, let's say, I want to read 10 bytes out of this file. So, I can make a byte array, b, array, colon, equal, make, a call make. I make it a byte, I give it the type, and I say, comma, 10. So, now I have this byte array, empty byte array. Then, I can call f.Read. F is the file handle that was returned by open. Call f.Read pass it the byte array as the argument, and it will then fill that byte array with the first bytes out of this file. Now, note that if I call it again with that same byte array, it would fill byte array with the next 10, right? Every time, the head of the read head actually moves. So, I read the first 10. If I read again, it's not going to read the first ten again, it will be the next 10 until I close it and resets the head. This function returns two things an error, if there's an error. So, if you're trying to read something and you're out of space, as empty or something like that, you reject file might throw an error, but otherwise it returns NB which is the number of bytes that I read. That sometimes the number of byte should be equal to the size of the byte array, but it doesn't have to be, you can have what's called a short read. Maybe the byte array is size 10, but there are only five byte sets left in the file, then you only read five out. So, nb would equal five in that case. Then, when you're done reading, you just call f.Close and it closes the file, and resets the head for the next time. So, next example is Write. This time using the OS Package as well. So, first thing we're going to do, is we want to write a byte array into a file. So, we first create the file on this case, os.Create. We could have opened the file, we could have opened the existing file and open it to append to it. But in this case we're just going to create just for an example. We're going to create a new, calling outfile.txt and then we get this file handle f that refers to that file. Then, we make a byte array with using a, sorry. Actually this is a slice, but we make a slice by calling b array, but this slice has three elements in it. One, two, three, we want to write these. So, we call write, f.Write, f dot write, we pass it the byte array and it just writes those three bytes into the file. Now, another thing that we can do, there's another function for writing called WriteString that takes an entire string instead of a byte array it takes explicit string and writes that. So, you can call WriteString, write, "Hi" or something like that, pass it a string, it writes that into the file and which has to be a Unicode Sequence.