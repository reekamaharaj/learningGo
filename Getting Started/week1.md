# M1.1.1 - Why Should I Learn Go? (Advantages of Go)
So, why should you learn Go? What's unique and good about the Go language? I'll go over some of the highlights of that. Different people have different opinions, but there are certain features that are pretty uniformly understood as being advantages of the Go language. So, some of the advantages of Go. First, runs fast. Okay, that's always a good thing, and I'll talk a little bit more detail in the slides about why it runs fast, and faster than what, right? Doesn't run fast than everything, but it runs fast than a lot of things, and we'll talk about why. Garbage collection, that's another feature. That in similar languages, meaning languages that run fast like Go does, they don't have garbage collection. So, garbage collections are really useful feature, I'll describe what that is. Simpler objects, now this could be an advantage or disadvantage, but the idea is that Go is essentially object oriented although, some might disagree, but it has this concept of objects, and these objects are generally, the object orientation is a little simplified as compared to other languages. So, this is good, it makes it easier to code. You don't have to use these complicated features, of course you never had to use them any way, but it makes it faster, and simpler to use. So, I know somebody might argue that look these features are useful features, I wanted them. Okay. But Go is actually a simpler object-oriented implementation than you would see in other languages like C++. Another feature of Go is that it has concurrency, efficient concurrency implementation built into language. So, there are a lot of these concurrency primitives that are built into the language, and that are efficiently implemented, and we'll talk about those. So, to start off with, let's go into that code running fast thing and tell you why that is the case. To talk about that, we've got to talk about a little bit about languages in general, differences between languages. So, I've got these three, very broad categories of languages for machines. So, one is machine language, next is Assembly language, next is high-level language, right? Now, that's a really big category, but let me explain. Machine language to start off with, that is the lowest level language, and it's directly executed on the CPU, on the processor. So, the machine language instructions are very, very straightforward and simple, add, multiply, add might add to register contents, put the result in another register, something like that, very small steps, each machine language instruction. Now, this runs directly on the processor, so there's that. There's assembly language and assembly language is basically machine language, almost a one-to-one mapping to machine language. So, in machine language, say you had to add instruction that might be represented as a sequence of zeros and ones, 11110000 that might be an add, Opcode for an add. So, in assembly language, you would use the word ADD. So, it maps one-to-one to the machine language equivalent, but you can read it because it's English. Now, it's concise English, I would argue it's hard to read, but it's English mnemonic, so a human could read that and could right that if you wanted to, and people do sometimes. If you want something to run really, really fast and really efficiently, then you'll write it directly in assembly language. That's outside of the scope of this class, that's hardcore, I'll call it. That is not something we're going to really cover in this class, but sometimes you do write directly in assembly language. So, there's assembly machine in assembly, and assembly language is basically a one-to-one mapping to machine language not completely, but very close. So, fundamentally they're the same complexity. They're the same language, but assembly language is easier to read. Now, as high-level languages that's everything else, that's a broad category. A high-level language is a language that essentially humans commonly use to program in. They are much easier to use than assembly language or machine language. They provide you with lots of abstractions that any program would be used to, for instance variables, right? Assembly language and machine language do not have variables, they have memory, and you can put stuff in it, take stuff out, right? There's no idea of a type or anything like that in assembly language or machine language, but high-level languages provide that to you, right? If statements. Now, assembly language, machine language, they have conditional branches and so on, but these are generally much harder to use than your standard if statement that you would see in any normal high-level language or loops or, for loops things like this. You can create these things in assembly and machine language, but they are harder to write than they would be in a high-level language. So, high-level languages are basically everything that most people program in. So, you can imagine these different categories. Now, the language that we're talking about Go. Go is of course a high-level language in this set of three categories, it will be considered high level. Remember that term high-level is subjective, okay? But I'll call it high level. So, all software that I have highlighted in the slide, all software needs to be translated into the machine language of the processor to be executed. So, what that means is, that if you've got a processor or some kind, some i7 or whatever processor you're working with, that processor does not know C or Java or Python or Go or C++ or any of those, right? All it knows is its own machine language, say x86 machine language, if it's an Intel based processor or an AMD or something like that, so it knows that machine language. So, in order for the code to execute on the processor, it has to be first translated into the machine language of the processor. So, even if it's C, Python, Java whatever it is, has to be translated. So, there is this software translation step that has to go on. Okay, now, this translation step, it can go on in one of roughly two ways. It can be compiled, it can be a compilation or interpretation, okay? Now, a compiled language is a language where the translation from high-level language to machine code happens one time before you execute the code, before you deploy the code, happens one time, okay? So, like in C, C++, Go, Java partially, there's a compiler, and you compile the code. So, somebody writes the source code, they compile it, and then they execute it, and they execute the compiled executable, right? The compiled executable is basically machine language code plus other stuff, but it's basically machine language code. So, the idea behind a compiled languages, the key thing we want to bring out anyway is the fact that this translation occurs once, it doesn't occur while you're running the code, right? It happens before you run the code, and then when you run the code, you are just running the machine language instructions directly because they're already compiled into machine language by the compiler. So, the other way to do this is interpreted, interpretation. In interpreted language what happens is, instructions are translated while the code is executed. So, what happens is, it happens it adds time to the execution because every time you see an instruction, and say Python, that code, that instruction has to be translated into machine code on a fly, and that takes a certain amount of time just to do that translation. So, in addition to actually executing the instruction, you've got to do this translation from the instruction into the equivalent machine code, so that slows you down. So, the translation occurs every time you run the Python code, say or Java, the Java byte code. I put Java as partially in both categories because Java it's compiled, but it generates what's called byte code, not actual machine code and then the byte code has to be interpreted at runtime. So, there's an Interpreter also in the Java virtual machine, but these interpretive languages require an interpreter to be executing while you're running your code because it has to be doing this translation as you execute the code, and so that slows you down. Now, this is a trade off between compiled code and interpreted code. The first level is trade off. One big difference you can see is, its compiled code is generally faster to execute, that's because you don't have to do the translation every time you run the code, so it is going to be faster. Now, there are people who would argue the opposite, but generally compiled code is a lot faster. Now, on the other hand though, interpreters make coding easier. So, the thing about interpreters is that, the interpreter itself, that program that is doing the translation of your code, it can help you, it can handle things that you, as a programmer, don't want to handle. For instance, in Python, I don't have to declare my variable types. I can just start using a variable and the interpreter will say, "It looks like he's using it as an integer, make it an integer." So, that's something that the programmer doesn't have to think about. Another thing that interpreters commonly often have is memory management. In fact, almost always they have this. They can manage their memory, and by that I mean, getting rid of variables and other pieces of data when you're not using them. So, when you use a variable, that variable has to go into memory somewhere, and that memory, if you keep making variables and using a memory space, you will eventually run out of memory, things will slow down and you'll run out of memory. So, you have to manage your memory, that is when you're done using an object, you want to get rid of that, de-allocate it from memory, and that happens automatically in an interpreted language, so the interpreter handles that. So, that's a good thing about interpreters. So, Go is a good compromise between this compiled and interpreted type of language. It's a compiled language, but it has some of the good features of interpreted language, specifically it has garbage collection. So, garbage collection is the automatic memory management that I'm talking about. So, this memory management, where should memory be allocated, so I'd say, "I need a variable x. Where should I put it in memory? What type of memory I should put it in?" We'll, talk about that a little bit later, but also when am I done with that memory, right? Because when you're done with the memory, you can get rid of a memory. You don't have to use it anymore, you can use it for something else. So, that's what I talk about memory management, that's what I mean and this happens automatically. The garbage collector can figure that out, it says, "Oh, it looks like this program is done with variable x, I will free that memory now," and that happens automatically. Manual memory management is hard. This is, if you've ever done C or something like this, you know this, deallocate memory too early, if you stop using it too early, then you will have false memory accesses, you still need it, so you'll use the memory that's already deallocated and errors crop up because of that. Also if you deallocate it too late, then you're wasting memory, you can have what's called a memory leak, where you have more and more memory that's not actually being used, but it's being blocked up because your machine thinks it's being used, right? So, at memory management manually is very difficult, and there are lots of errors, security errors too. So, Go has a garbage collection code included, so when it compiles your code, it also compiles garbage collection into your code automatically, and this is typically only done by interpreter. So, this is a compiled language that actually has garbage collection, which is a really good feature. Now, downside is that it slows down execution a bit, but it's an efficient garbage collector, so it doesn't slow down much and you get a lot of advantage of having this automatic garbage collection.

# M1.1.2 - Objects
So, Go language is object-oriented, but let's say, weakly object-oriented. So, what I mean by that is that it implements objects but maybe they have fewer features than you would see in another object-oriented language like Python or Java or C++ or something like that. So, I'm just going to summarize what object-oriented languages are, what object-oriented programming is very briefly just so I can highlight some of the differences in Go's implementation. So, object-oriented programming, it's really for code organization, in my mind is for code organization. So, you organize your code by encapsulating your code. You group together data and functions that are related to each other. So, this is essentially what a type is. So, what object-oriented programming and lets you do is essentially create a user-defined type, one that's specific for whatever application it is that you're building. So, typical types, you have integers, floats, that sort of thing. Those are generic. You can use those in any kind of program. But when you're making a specific application, you might like to have a type that is specific to that application domain. You can create that. Object-oriented programming allows you to create that. So, if you think about a type, your standard type, like an integer, each integer it has data, the number, the value of the number, and then it has functions, the functions that you can apply to the data. So, you can apply addition, subtraction, multiplication, that sort of thing. So, a type has data and has set of functions that you can apply to the data. So, object-oriented programming is the same idea. You're creating types. But they are more complicated, they can be more complicated, and they are specific to your application. As an example, let's say you're making an application and it's going to do geometry, some kind of geometric operations in three dimensions. So, many of the functions that you're going to write are going to operate on points. You're going to have this idea of points because you're doing 3D geometry. Each point is going to have some data associated with it, specifically x, y, and z coordinates. Maybe you want to put other data in there, but at least, you're going to have that x, y, z coordinates because in 3D. Also points are going to have a set of functions, a set of functions that you can use to operate on points. So, distance to origin, maybe every point has a distance to its origin. You can have a function that computes that. Quadrant, it tells you what quadrant. Maybe it returns what quadrant the point is in, something like this. There are a lot of functions that you can imagine that work on points. So, if I think about this idea of points, I got a bunch of data that I want all related together. So, I want the x, and the y, and the z variables for a particular point, I want them to be somehow associated together. Also, I'd like these functions that operate on points to be associated with that too. So, in typical object-oriented languages, you have this idea of a class. Now, I should note right now, Go does not use this term class. But I bring it up because it's used in other object-oriented languages and so people might be familiar with this idea. So, this class, it defines that may I make a point class, and the class defines all the data that would be inside a point. So, x, y, and z, maybe they're all floating point value, something like that. The class would define all the functions that you would have that are associated with points, distance to origin, quadrant, and so on. So, that will be the class. Then an object is an instantiation of the class. So, I can make my point class but then I might have many different actual points with actual data values inside. So, if I have a triangle, I've got three points with three sets of x, y, and z values. So, I might have this point class that's sort of a general template of what point should have, but then the point objects, my three-point object will have actual values for x, and y, and z and so on. So, that's the idea, that's the terminology that you normally see use, classes and objects which are instances of that class. So, different languages have this. Java is very popular, Java, Python, C++, and so on. Now Go, we don't use this term class, instead they use structs. Now structs, actually, this goes back to C and probably before that. But the idea of a struct is a struct is just the data. So, the different types of data that you want to associate together. So, like with our point class, you'd have a point struct and it would have an x, and a y, and a z, maybe they're all three floating points. So, just the data are related together. But also you can associate methods or functions with those structs. So, the struct ends up being like what you would call a class in a normal object-oriented language. So, you got the structs that had some data, some fields of data associated with them plus some methods that you want to define. Now, Go's implementation of structs is simplified compared to traditional implementation of classes. So, you don't have inheritance, you don't have constructors, and you don't have generics, none of those. Now, this, one can argue it makes it easier to code, also it makes it efficient to run. So, it typically runs faster. But it can make it easier to code unless you like those features. Now, if you'd like inheritance, and generics, and constructors. Then, you can see this is a disadvantage. But Go is different. It has objects but is different than traditional object-oriented implementation and a linear object-oriented implementation.

# M1.1.3 - Concurrency
One of the big advantages of Go, is its implementation of concurrency. So, we'll talk a little bit right now about concurrency, what it is, and why it's useful, and how Go implements it, how there are built-in constructs in the language that make it easy to use concurrency. So, I'm going to start by talking about performance limitations of computers. The reason for this is because a lot of the motivation for concurrency comes from the need for speed. A lot of the motivation, not all but a lot of it does. So, that's why I'm going to introduce these performance limits on machines and how concurrency can help you get around these performance limitations. So, Moore's law, so just to summarize, you probably heard of this law. But in case you have not, Moore's Law, it basically says, that the number of transistors on a chip doubles every 18 months. Now, this used to be the case, it is not the case anymore, recently. That has changed, but this used to be the case and so, because of this doubling of transistors, what happened would be, machines would speed up just. Because as the transistors got a little smaller and they would be closer to each other, you could increase the clock rate and so clock rates would just increase, increase, increase. I remember when I was in school, which was a while ago, you'd buy a machine and seriously a few months later there'd be another machine, same prize, it was faster and it was frustrating. So, these clock rates were just going up and up and up because the number of transistors were just increasing. Now, performance then that was great right and in fact, what that meant was that, I'm a hardware person mostly, my background is a lot of hardware. So, I've always felt like software designers, programmers would get lazy. They'd write code and it didn't have to be particularly efficient in terms of memory or in terms of speed because they knew that pretty soon hardware people would double the number of transistors and fix all their problems for them. So, that's how it used to be, but that is not happening anymore, because Moore's Law had to slow down. There are several reasons why probably the biggest would be the power consumption and therefore temperature constraints. So, when you pack these transistors onto onto a chip they generate heat. Every time they switch they consume power which generates heat. If you keep increasing the clock rate, then the switch zero to one, zero to one more frequently higher rate and they create more heat and the chip would physically melt. So, if you've ever opened up a machine you see they got fans blowing over the chip. In fact usually, when you open up a box, you see on the box some big heat sink, big gnarly-looking piece of metal that's actually attached to the processor. That's just to distribute heat. So, the wet air blows over at the fan blows over it and distributes the heat so it doesn't melt. So, this is air cooling, right? We are basically at the limits of air cooling. Air cooling can only remove so much heat per unit time. So if you get, if you clock these things much faster with this density of transistors, you're going to melt the thing. So you can't keep increasing the clock rates. So, that's performance limit that's happening with machines, the clock rates are not going up as fast as quickly as they used to go up over time. So, how do you get performance improvement even though you can't just crank up the clock? So, one way to do this is to use parallelism. So, this is typically implemented simple and in a number of ways but you see this as an increasing number of cores on chips, this is one way that you see it, right. So, you got quad core machines, these are common, right. There are four copies of the core on there and you get more. Heck, if you go to a GPU that thing might have a 1,000. 1,000 processor core is all in a inner massive array. So, these cores, the number of cores on the processor increases over time and that helps you because you can perform multiple tasks at the same time, potentially, not always but sometimes. If you've got four cores, you can do four things at once. That can improve your speed, you can get things done faster. Now it doesn't necessarily improve your latency, but your throughput will improve potentially. So, difficulties with implementing parallelism, there are many. But programming wise there are difficulties. So, for instance, when did the tasks start and when do they stop? A programmer has to decide this. For tasks, these tasks are not completely independent. So, what happens when one task needs to get data that's generated by another task, right? How does this data transfer occur? Also, if you've got multiple tasks running at the same time, do these tests conflict in memory, right? They should not. You don't want one task to write to it's variable A and that overrides variable B in another task. So, these are all problems that happen when you have concurrent execution going on. Because even if you got multiple cores you got to worry about the memories, are they sharing memories?, do they have separate memories? This is all features in the hardware but the programmer has to often be aware of these things and it's hard. So, writing this type of code, code that can execute in parallel can be difficult. So, in comes concurrent programming. Concurrency is the management of multiple tasks at the same time. So, when I say at the same time, they might not actually be executing at the same time. Maybe they're executing on a single core processor. So, they're not actually executing at the same time, but they are alive at the same time. So, they could be executing at the same time if you had the resource, but they need to be going on at the same time. So, maybe one is paused while the other ones running but they are all alive at the same time and need to be handled at least from the user's perspective at the same time. So, this is key for large systems. There are big systems have many things, many pieces going on and they're not all executing sequentially. You want them you want to be able to consider 20 things at one time. Now, maybe they're not actually executing at the same time but you would like to have the possibility of executing them in parallel if at all possible, just for speed. So, concurrent programming it enables parallelism. So, if you can write program code, write code so that all these tasks can be alive, multiple tasks can be alive and communicating the same time, then if you have the resources, the parallel resources multiple cores, multiple memory stuff like this then you can map them onto those parallel resources and get parallelism. So, you can't just take a regular piece of code and say okay I'm going to run it on five cores, that won't work. The programmer has to decide how to partition this code. I want this running on one core, this on another, I want this data here this data there and so on. So, that's what concurrent programming is about. The program is making these decisions that allow things to run in parallel. If parallel if the hardware exists. So, concurrent program includes several things, we'll go into more depth and layer in the concentration, but specialization rather. But management of task execution, so when our test starts and stops, how do two tests communicate, send data back and forth, share memory if they share memory and how did they synchronize? So, there are times where one task has to do something for the next task can start. So, there are times where two tasks can't be executed completely in parallel. There has to be some sequential behavior. This test can't start until this task ends and so on. So, that's synchronization and you have to be able to manage that inside your programming language. The programming basically have to say, express inside the code where synchronization needs to occur and where it doesn't. So, that's what concurrent programming is and it is important if you want to be able to exploit parallelism when it exists. So, concurrency in Go. So, basically the thing about Go, is that Go has a lot of concurrency primitives built-in to the language and implemented efficiently. So, Go routines, each one of these Go routines represents a concurrent tasks, basically a thread. Channels are used for concurrent for communication between concurrent tasks. Select is used to enable synchronization. These are just the high level basic keywords that you can use. But we'll talk more about these later on in the specialization. But concurrency, having concurrency built into the language and have an efficient implementation is advantageous if you're doing concurrent programming which more and more, especially with all the cores that exists in processes these days has become more and more important.

# M1.2.1 - Installing Go
We'll talk right now about how you download and install the Go tools, just to get you started running a program. Right now, we'll talk about the download process and then next I'll go through actually doing it, showing you how to compile your first program, but right here, just talk about installing, which is fairly straightforward. So, first thing you are going to do is go to golang.org, and this is a snippet of the page when you go there. This isn't the whole page, I had to fit it on the slide, but this is what it basically looks like, at least right now it does, that can change over time of course. You can see the gopher, see that little gopher. You'll see that gopher icon over and over again. Gopher is the mascot of the Go programming language like Unix, you got demons. So, Go you have the gopher, but the main thing to look at here is that button down there that says Download Go. So, that's first thing you're going to click on. You're going to see Download Go, you click on that. Actually also look at this, on the left side, when you go to the web page, you'll see the whole screen. I've cut it off here, but on the left side, you could see there's a yellow box there where you can type in Go code and click on the Run button, it'll compile and run it. So, it'll compile it remotely and run it remotely. We're not going to use that, instead we're going to download the compiler, we're going to download Go Download to your machine locally and you'll be doing it locally, but if you want to just fool around, you could type in their, type some go program in there, click run, and it would actually execute it. So, what we're doing now is we're going to click Download Go to download the tools. Now, when you do that, you come to a page that looks like this. Now, again I'm only showing a part of the page, there's more below it and to the right. Basically, when you download Go, you can download the precompiled versions for different platforms. They've got Windows, and Linux, and Mac OS and you can also download the source if you want to, and you could compile all of the Go from scratch, it's whole tools chain from scratch if you wanted to. We will not be doing that. That is pain. We won't be doing that, but know that you could, it is open source and all the sources are right there for download if you want it. So, I'm going to be doing this on a Windows machine, although you could be doing it on a Linux or a Mac OS machine, either way. So, go for the feature downloads, they make it pretty easy. For Windows, you pick that MSI file that they've got highlighted right there. Basically, what you want is the newest stable precompiled version. I don't see unstable ones on here, but I would recommend the stable, but it's up to you. Anyway, you go for a new version, click the featured one and you download the MSI. Now, once you get that, remember if you have an antivirus on your machine, it can pop up and worry about this and complain, but just say okay. Then once you start running it, it'll start a wizard. Now, you've seen these installation wizards and this is sort of a standard installation wizard. Just obey the wizard and click Next, Next, and it will ask you where you want to install the tool, what directory you want it in, and so on. The default locations were fine with me, but that of course is up to you.

# M1.2.2 - Workspaces & Packages
Right now, we're going to talk about how code is organized in Go. First, we'll start with a workspace. So there's this idea of a workspace, and it's basically a directory where your Go stuff will go, so your Go files. Your Go source files and other files will go in this workspace directory. Typically, there's a actually a hierarchy of directories within your workspace where you will store the different types of Go files that you're working with. Now, the reason why we're doing this, why the Go language defines this hierarchy of directories is because common organization is good for sharing. So, a big motivation behind Go, the Go language is for people to work together easily. So, remember that when you're programming, not necessarily in this class, in this class you're working on learning the language, the different aspects of the language, but when you get outside and you're working in a company or something like this, it's never one person alone, it's always a big group. You're working with people all over the place. They have to be able to work with your code, look at your code, merge it with their code, link it to their code that sort of thing. So, there's always this sharing going on. Maybe you want to upload to GitHub and have a communal group of people working on code together. So for that, it is nice to have a common standardized organization of your files, right? It makes it easier to share because then everybody knows where everything is. Tools know where things are and stuff like that. So, inside your workspace directory, what is recommended are these three subdirectories. The source directory, it contains the source files, your source code your Go code. Package directory contains packages, the other packages that you're going to link in that you need, and then the bin directory that contains all your executables, your compiled executables. Now, the programmer typically has one workspace for many projects. So, I typically use my one workspace directory and I can have 20 projects, 20 different Go projects I'm working on in the same workspace directory. That's common. You don't have to do that but that's common. So, one thing to remember about these directory hierarchy is that it's recommended but it's not enforced. So, this idea of having the source subdirectory, the bin subdirectory, and the package subdirectory, that's not enforced. So, for instance, you can have an executable in the source directory if you want. It is not neat and it's harder for people to share, but it's going to run. You can compile it and put it anywhere you want and run the executable. So, it's not enforced is just a recommendation to make it easy to share with other people. So, the workspace directory, you do have this one workspace directory though, and this workspace directory is defined by the GOPATH environment variable. Now, the GOPATH environment variable depends on, how you set environment variables is going to depend on your operating system. Normally, what happens is like on my Windows machine, but the Chaperone, Linux and OS X machine two, is that the GOPATH directory is set for you automatically during the installation process. So, that wizard, the install wizard, it should define the GOPATH environment variable. Certainly, on a Windows machine, the default directory where it sticks it, where it puts it is C:\Users\yourname. So, for me, \user\Ian\go. It sets that as your workspace directory. Now, I noticed that when I installed everything, that was my GOPATH. What you see up there \Users\Ian\go. But it actually didn't create a Go directory. So, there was \Users\Ian. I had to create the directory myself, which is fine. But I had to make that directory and put my stuff in there. But understand that that's the default workspace. You can change that and you can go to your GOPATH environment variable and change your environment variable in your operating system if you want to, but for now I'm just assuming that we're using the default Gopath. So, with Go tools, I'll assume that the code is inside the GOPATH somewhere. Now, there is this other concept of packages. Your code is organized into packages. A package is a group of related source code files. Each package can be imported by other packages. So, this is the use for this. The main use for this is when you're working with other people, other groups of people in other places, you write all your code in one package, they write all their code in another package, and then if you need to use their code, you can use their code, you can import their package. So, it's good for software reuse that's the main goal. The first line of the file names the package. So, what I'm showing here in the picture, you can see these two pink boxes up here. These are two packages that are defined and you can see the first line of, so those are two different files, different source code files. You can see the package names are listed at the top, package package. There's a bunch of code in there and they're associated with that package name. Then in blue, I have some other piece of code in a different source file and it needs to use the packages from the other two people. So, I have an input statement at the top of my blue file and I give the package names that I want to import. So, I can use these other two packages in my code if I want to. So, this is how packages get connected to each other. It's very convenient if you're working with somebody remotely or somewhere else that you can clean separation of the code. Now, there always has to be one package called main, and that's where execution starts. So, there's got to be one package called main and you'll note that in the code that we're working on in this course, we just have one package and it is called main. Because we're not making such big code, we have different groups of people working together with different packages right now. We're just writing one package called main. But there must be one package called main and when you build the main package when you compile it, it makes an executable one. So, note that when you build another package on the non main packages, then it doesn't make it executable for those, or not a running executable because it's not going to be executed directly. It will be incorporated into some other package. But the main package, that's what's going to be run, so when you compile that, when you build it, build\compile you get an executable file. So, the main package needs to have a function called main. Main is where code execution starts. So, you can see the example code right here. It's just printing, "Hello world". If we say package main, import format, so that import right there is importing a package. Format it's not a package that I wrote. Format is one of the packages that comes with the Go tool. So, when you download the Go tools you get all these standard packages including format. The format package has a lot of functions in it. We'll talk more about it later. But one of the functions that it has this print statement, so Printf is included in the format package, so we have to import that package, and then we make our function main and in there it just says fmt.Printf hello world. So, pretty straightforward.

# M1.2.3 - Go Tool
So, we're going to talk about the Go Tool a little bit, just overview of it really. It has a lot of features, and we'll get to those in different courses actually during the specialization. We'll talk about a little bit of it now, but start off with import. So, just to restate what import does. It's a keyword, and it's used to access other packages. Now, for the most part, the packages that we're going to be importing will be the built-in packages, the ones that come with the Go language, to implement different functions that we're going to use in the course. So, for instance, right now, right off the start, we are going to use this format package, fmt, and it has a printf statement built into it, and we use it for printing things. Now, what happens is when you do an import, the Go Tool when it does a build, it has to find the imported packages. So, it searches through the directory specified by the GOROOT and the GOPATH environment variables. So, if you keep everything inside the GOPATH and the GOROOT, so inside your work space, it'll find them. If you decide you want to import some package from some other place and maybe it's installed in a different directory, something like that, then you're going to have to change your GOPATH and GOROOT paths. You're going to have to increase them, change the path, change the environment variables, so that it can find them. But, that won't be a problem for based of the majority of this course, we're not doing that. But I'm saying in the future, when you're working with really big code, you might need to alter these environment variables in order to be able to find the packages that you're looking for. So, the Go Tool. When you download Go, you get this Go Tool, and it's a general tool used to manage Go source code. There are many commands, a bunch of different commands that you can use the Go Tool to do. The first one is going to be go build. So that, it's just compiling the program. The arguments to go build, you can have no arguments, in which case it just compiles a.go file in the local directory. But you can give it a bunch of packages, a bunch of package names, or a bunch of.go files that you want to build. You can give that as the arguments to this go build command. It'll go build whatever you tell it to build, or you could just say go build. Actually, that's what I did in the demo. I just said go build, and I was already in the directory where I had my main package, and so it just compiled that. So, it creates an executable for the main package, and the executable has the same name as the first.go file. So, if you're just using one.go file, you're just going to get that as the name. The.exe suffix is what you're going to see for executables in Windows in general. So, you'll expect to see a.exe, and it's executable, and that should be in the directory where you did the build. If you give it no other arguments, it'll just place it in the same directory. Now, there are tons of arguments to these commands, and I'm not really going to go through, but you can have arguments where you can tell it to build and put the executable in a different directory and so on. I'm not going to do that right now. We'll finesse that stuff later. So, some of the other Go Tool commands, just go through these a little bit. Go doc. Go doc prints documentation for a package. Now, we'll go over this later, but as a programmer, you have to put the documentation in your package, and go doc will just pull it out of all your packages, and print it. Go format, that format source code files. So, we're not going to get heavily into this, but if you program at all, you must have heard arguments about, "Oh, you need this type of indentation and stuff like this." So, this go format will just indent it the way it should be done. You just give it the source code file, and it'll indent it right to get past all those arguments. There's a standard indentation. You don't have to use it. Remember, the indentation isn't forced on you. This isn't Python or something like that. You don't have to, but go format will do it for you, so why not. Go get downloads packages and installs them. So, if you want to get new packages that do interesting things that aren't standard default packages, you can say go get and give the name of the package, it'll go online, find the package, download it. Go list, list install all the install packages. Go run compiles go file, and it runs the executable. So if you just say go build, that compiles it, and does not execute it. But go run actually compiles it and then executes the executable in the end. Or, if it's already compiled, it will just run the executable. Now, you don't need go run, like in my demo, I think I did a go build to get the executable. I think it was called hello.exe. Then, I just typed hello.exe at the command line, and it executed it. So I didn't have to use go run in order to run the executable but you can. Go test, actually the last course, the fourth in this specialization is actually about testing, and we'll get to that then. Go test, it runs tests. It looks stuff, basically, you have a bunch of test files that end with this underscore test.go, and you can run these tests using the go test command. But we'll cover that later.

# M1.3.1 - Variables
So now we're going to start talking a little bit about the Go language, will broached the topic of variables and talk a little bit about those variables that are in every high level language and we'll just see how Go implements it. A lot of this is very similar to what you've seen in other languages, some things are a little bit different. So first there's naming. Every- you need names. Names are variables for functions, you need names to refer to things in your code. So names for variables and things like that, they need to start with a letter. They can have any number of letters and digits and underscores, they are case sensitive in Go and you can't use keywords. There's a list of keywords you can google these or look them up but "if", "case", "package" all the different keywords, the language you can't use those as the names. So, variables are basically data stored in memory somewhere. And every variable has to have a name and a type. So all variables have to have a declaration, specifies the name, and the type of the variable. So, here's a really simple variable declaration. Just as var, x, int. So var is the key word for a declaration of a variable. After that I have the name. So my name variable is called x and then after that I have the type, var, x, int. That's it. That's a declaration of this variable x since it's an integer. And the compiler needs to know what type of variable it is, what the type is, so it knows how much space to allocate, what operations to perform that type of thing. You can declare many on the same line if you want to, just comma-separated. So var x, y int and you can do that as much as you want. So variables have types. Type defines the values that a variable can take and the operations that can be performed on that variable. So for instance common types, basic types, integer, floating point, strings. Integers, the data, the values that they can take are only integral values right? They are integers and the operations you can perform are integer arithmetic, plus, minus, times that sort of thing and there are a set of other ones we'll talk about them a little more detail. Floating point, those are the data that they can have, the values they can have or fractional like decimal values and there you have a set of operations, arithmetic operations. Actually they look superficially the same as the integer operations, plus, times, divide but they may actually be implemented with different hardware right? Because floating point division say is significantly more complicated than integer division. So there's oftentimes as special hardware just for floating point divide things like this. We don't have to know that as programmers but the machine has to know which operation to map it to. Then strings. So strings they're a sequence of bytes represented in unicode and we'll get into that later. But it's a sequence of bytes, that's the type of data the values it can take on and then the operations you can perform on strings. There are many of them. String comparison, string search, concatenation, all sorts operations that you can you can perform on a string. But the point is the type specifies these things. It specifies what data the variable can hold and how big that data can be right? Because you need to know how much space in memory you're going to need to allocate for this. The compiler needs to know that and also what operations are going to be performed on it. So what that's for is eventually the compiler is going to have to take these these operations that you type and go and compile them into machine code instructions for whatever the hardware platform is, and those machine code instructions can be different depending on the type. So for instance you can easily have an add for an integer, an integer add up machine code instruction which is different than a floating point add right? Integer division which is different than floating point division and so on. So this is why the compiler needs to know the type so it knows how to do the compilation, how to convert it into machine code.

# M1.3.2 - Variable Initialization
[MUSIC]
Play video starting at ::11 and follow transcript0:11
So we're talking about variables and we're going to talk about how you initialize them, but first, let's finish up the types. So every variable has to have a type.
Play video starting at ::20 and follow transcript0:20
And you can make type declarations where you actually define an alias, an alternate name for a type. So sometimes this is useful for clarity inside a particular application. For instance here, it could help you, say you got you got some kind of application and it's working on temperatures. Temperatures are something that it's manipulating, right? And every temperature you want it to be a floating point value, 64 bit floating point value. So you can define a new type, an alias for a new type, type Celsius float64. In that case, Celsius is exactly the same as float 64. Now, you can always declare your variables to be float64, but Celsius might make sense in the context of the application, right? Maybe the application is about temperatures. So maybe you want to rename is [COUGH] just to make it clearer for you as a programmer. Also, like the next one, type IDnum int. Maybe I want to, maybe I'm making some code that implements a database of users or something. And every user has an ID number. So I know this type, this concept ID number. I'd like to, I know it's an integer, but I want to name it. I want to give it that name IDnum, so that I know every variable that it declares an IDnum, it is an IDnum. I know something about it just based on the name of the type. So once you declare a type like this, type Celsius float64 or type IDnum int, you can now declare variables using that alias. So I can say var temp Celsius, right? And now temp is going to be float64 because float64 is aliased by Celsius. Also, var pid IDnum, pid is actually an integer. But we call it an IDnum and it makes things more clear.
Play video starting at :2:4 and follow transcript2:04
So initializing variable values, every variable has to be initialized somehow before you use it.
Play video starting at :2:11 and follow transcript2:11
One way to initialize it is in the declaration itself. So you can say var x int = 100. And that will make x an integer, it'll declare it as an integer, but it'll also set it equal 100. Or you can just say var x = 100. Now, if you do that you're not saying you want it as an integer. So it will infer the type, it compile with a further type based on the type of the right hand side value. So the number 100 is an integer, so it says x must be an integer, makes it an integer. Now, remember, sometimes this is an issue because maybe it infers something you don't want, right? I like to specify myself, but maybe. So, for instance, say I say x = 100, but I really want it to be a floating point. I mean, 100.something, right? But I call it 100 because that's my initial temperature that I want, but I want it to be a floating point value. This will, if I don't specify, it'll say, well, 100 could be an integer, it'll infer it as an integer. And then if I try to set x to 100.1, I'll have a problem.
Play video starting at :3:10 and follow transcript3:10
So I like to specify the type, but you don't have to.
Play video starting at :3:16 and follow transcript3:16
Next up, initializing after the declaration. So you can just say var x int, and then afterwards you could say x = 100. And then it'll follow the line. That's another way. Now, if you don't explicitly initialize a variable, it'll still get a value. It'll get the zero value for its type. So, for instance, say I say var x int. The 0 value for its type is 0, right? So x will be automatically assigned to a 0, initialized to a 0, if I don't say anything else. If I say var x string, the zero value for a string is just the empty string. So x would be initialized to the empty string in that case.
Play video starting at :3:54 and follow transcript3:54
Now, another way to initialize variables is using a short variable declaration.
Play video starting at :3:59 and follow transcript3:59
Now, in this case, you're performing the declaration and the initialization together using the colon equals operator. So up on the slide x := 100, okay? When you say that, this is a case where x has not been declared yet, right? So this statement actually declares x and initializes it. Now, the declaration, what happens is that when you use that colon equal, the type that it sets it to be is whatever's on the right hand side. So 100 in this case. It sets, it looks at 100, says, that's an int and it infers x to be an integer and then it assigns it to the value 100. So variable is declared as a type of expression, the type that's on the right hand side. So it does, this type of variable declaration, it does the declaration and the assignment together in one line with this special operator. You can only do this inside a function. So you can't do a short variable declaration outside a function, that's not legal. So just know that.