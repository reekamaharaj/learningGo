# M4.1.1 - Polymorphism
Module 4, Interfaces for Abstraction, Topic 1.1, Polymorphism.
Play video starting at ::6 and follow transcript0:06
Polymorphism is a property very commonly associated with object oriented programming. It's the ability for an object to have different forms depending on the context. Okay, so what does that mean, different forms? That could mean a lot of things, but what it typically means is you can have a function or method with one name, area. And it does one thing for one object and another thing for another type of object, okay? So for instance take area, okay? If you want to compute the area of a rectangle, that's base times height. You're going to compute the area of a triangle as one-half base times height. A function name is going to do two different things depending on the context. If you're doing it with respect to a rectangle or with respect to a triangle, so that's what polymorphism is. So you would say area is polymorphic because it can do two different things depending on the context.
Play video starting at :1: and follow transcript1:00
So another way to think about it is that these two area implementations, they are at a high level of abstraction. They're identical. What they do is they compute the area, right? No matter what the object is, if it's a rectangle or if it's a triangle, the area is what's computed. So at a high level, forgetting the detail, they do the same thing. At the low level and how they actually compute the area and they are different, right? So really polymorphism is a way of establishing an extraction. These things are the same at the high level of extraction. But underneath they're different, right? So that's what we want to allow. It's useful for a lot of reasons. So we need Golang to have some type of support for polymorphism. So what I'll first describe is how polymorphism is usually implemented in traditional object oriented languages. So one thing that is usually used in object oriented languages to support polymophism is inheritance, and Golang does not have inheritance, and so I'll just say that again, Golang does not have inheritance. Inheritance is where you get a series of classes, and they have this class, subclass, superclass relationship, or sometimes you call it parent and child class, parent class, child class. So the superclass is the top level class, and the subclass extends from the superclass. And the subclass inherits the methods and data of the superclass. So as an example, maybe I've got a speaker superclass, and a speaker is supposed to represent everything that can speak, all right? Anything that can make noises, okay, you call that that a speaker. Now, underneath speaker, a subclass of that might be cat and it might be dog right? because cats can speak. They can make noise. Dogs can make noise. So maybe I've got this subclass cat, subclass dog. Both subclasses of this superclass speaker. And cat and dog will both inherit the properties of the superclass. So my superclass speaker, let's say it has a method called speak. And that just prints out whatever noise the creature makes. So speaker, since it's generic, and the superclass, its speak method will just print out noise, arbitrary noise because it's generic. But then the subclasses cat, dog, they'll also have a speak method. They'll inherit it from the speaker superclass. So they get the same properties, they extend down.
Play video starting at :3:31 and follow transcript3:31
So cat and dog are different forms of speaker. And this is where the polymorphism, they're different forms of each other, this is where polymorphism concepts come into play. And remember that Go doesn't have inheritance. Now, inheritance is one thing that you use in a regular object oriented language to support polymorphism, but you also, on top of that, you're going to need another property, overriding. The ability to override a method. So a method is overridden, a subclass overrides a method when it redefines a method that it inherits from the superclass. So in the example we're talking about here, you've got the superclass speaker. And under that you've got the subclass cat and subclass dog. And speaker has this speak method and cat and dog inherit the speak method too. But without overriding the speak method, the cat speak method and the dog speak method do exactly what the superclass, what the speaker's speak method does. They just print out noise, right? Which is arbitrary. So what you want is for the cat speak method to print out meow, and the dog speaker method to print out woof. So what happens is, that's called overriding. The cat subclass will redefine the speak method to print out what it wants, meow, right? And then the dog subclass will redefine it to print out what it wants, woof. So now the speaker class, the speaker superclass, it has its speak method, and cat also the speak method, dog also the speak method. But the cat speak and the dog speak do two different things, okay? So cat and dog classes have overridden the definition of the speak method with their own new definition of the speak method. So now you can say speak is polymorphic. Because speak, it has two different implementations for each class. So speak in the context of the cat, it'll print meow. Context of the dog, it'll print woof. But the idea is to support polymorphism which you normally see in object oriented language, you see inheritance, and then you also see the ability to override a method. So both the subclasses inherit the speak method, but then they can override it and define it the way they want. And one thing to note is that they actually use the same, even though they're overriding the method, they use the same signature. So this function signature is, the method signature is the same. So this method speak, it has the same name, in both cat and dog class, it has the same arguments and the same return types. So the signature will stay the same and you'd call it polymorphic in that case. Thank you.

# M4.1.2 - Interfaces
Module 4, Interfaces for Abstraction, Topic 1.2, Interfaces. An interface is a concept used in Go and it helps us get polymorphisms. So we don't get inheritance, we don't need inheritance, we don't need overriding. We can use interfaces to basically accomplish the same thing. And I think it's in a better way. I think it's cleaner. But this is up to, this is up for argument, right? because people who are used to Java, or something like that, will like it the other way. They'll like their inheritance and want to fight to keep it, but Go does this in a different way. So an interface is basically a set of method signatures. So by signatures, I mean the name of the method, the parameters of the method, and their types, and their return values, and their types. So that's all it is, there's no implementations, implementation of a method, right? So it just defines the signatures to the method. So it says the methods have to have this name, these parameters, these return values. That's an interface. So it's not a type or anything, it's less than that. It's used to express conceptual similarity between types.
Play video starting at :1:12 and follow transcript1:12
So what I mean by that is say I've got an interface called Shape2D, right? And that's my interface, and it's supposed to represent two-dimensional shapes. So all two-dimensional shapes, I'm going to say they have to have two methods, okay? An area method and a perimeter method, right? If it's a two-dimensional shape, you gotta be able to compute the area, you gotta be able to compute perimeter. And then I call it a two-dimensional shape. So my two-dimensional shape interface just says look, gotta have these two methods with the arguments that I say. In this case, no arguments, right? You gotta have these two methods in order to be considered a two dimensional shape. But if you have those two methods, any type that has those two methods, it can be considered a two-dimensional shape. That's what an interface is saying. So it's saying that they are conceptually similar, a circle, a square, a rectangle, a triangle. You can compute the area of all those and the perimeter of all those. So I'm going to call them two-dimensional shapes So, satisfying interface. A type satisfies an interface if it actually defines all the methods specified in the interface. So remember that a method in an interface, an interface doesn't specify. It doesn't design, give you the method. It just gives you the signature for the method. It doesn't implement the method. So if a type actually implements all the methods in the interface with the same method signatures, so same arguments, same name, same return values, then that type is said to satisfy the interface. So for instance, I can have a Shape2D interface. And I have it two types, a Rectangle type, a Triangle type. And if the Rectangle type and the Triangle type both define an area and a parameter method, with the appropriate arguments and return values. Then you will say Rectangle and Triangle both satisfy the Shape2D interface. And so they can be considered to be two-dimensional shapes. Now Rectangle and Triangle can have lots of other methods besides the area and perimeter, right? Any number of other methods. Also, Rectangle and Triangle can have lots of other data. Maybe they're structs, and struct types, and they have x, y, z points. Who knows what they have, right? None of that matters. As long as they have the area and perimeter that is specified in the interface, then that's enough. And they can be considered to be satisfying the interface and considered to be two-dimensional shapes. So what that accomplishes is it basically accomplishes what you get from inheritance and overriding together, right? So now I got Rectangle and Triangle. If they're both Shape2D, if they satisfy that interface, then they both have area, they both have perimeter. But their area and perimeter methods can do completely different things, right? because when you compute the area of a rectangle, it is different than computing the area of a triangle, right? So their implementations can be different, but they have the same name. And at the high level they form the same thing, they compute area. So in this way, we're using interface to accomplish in Go lang what you would use inheritance and overriding to accomplish typically in a thing like JAVA or some other object oriented language. So how do you define an interface type? It's pretty straightforward, it looks sort of like a struct. There we got Shape2D, so I say type Shape2D interface. Just use the keyword interface after the name of the interface. In curly brackets, I start listing the signatures of the methods. So in this case is only two method and two signatures that I need, area and perimeter. Both of them area and perimeter take no arguments and they return a float, a 64 float. So that's it, that's how you define this interface. I just list all these method signatures that I want to put in the interface. Now then, say later on in my code I defined a type Triangle. And I don't even say what's in it. I just said it have an open curly bracket, close curly bracket, with some dots, just to say it doesn't matter what data I'm putting in that Triangle, right? Maybe that data Triangle, maybe it's a struct or something like that, who knows what it is. It doesn't matter, but whatever it is, as long as I define a function area whose receiver type is a Triangle and a function perimeter whose receiver type is also a Triangle. And the area and perimeter also take no arguments and return float64s, just like the interface. Then this type Triangle is said to satisfy that ShapeID interface, Shape2D interface, rather. So and it doesn't matter what other data is in Triangle, what other methods are using Triangle as a received type. As long as got area and perimeter and it matches and satisfies the interface. And one other thing before I go on, is that you don't have to state it explicitly. So in other languages that have interfaces, you often have to say explicitly the Triangle satisfies this interface, the Shape2D interface. You don't say that in Go. You just say here's the interface and here's my type Triangle, and here the methods for Triangle. And the compiler figure, it can do the matching automatically. So I see you have a area in perimeter, I will treat you just like I treat anything that satisfies the Shape2D interface. Thank you.

# M4.1.3 - Interface vs. Concrete Types
Module 4: Interfaces for Abstraction, Topic 1.3: Interface versus Concrete Types. So concrete types and interface types are fundamentally different. A concrete type is a regular type, it specifies the exact representation of the data and the methods, data specifically, but also methods that are used in the type of the receiver type. So, they're fully specified, and it has complete implementations of the method, of all the methods. So any methods that use this type as a receiver type, they're completely specified. But the first thing is sort of a big difference between interface types and concrete types is that the exact representation of the data is in there. So if you have a concrete type, it's going to have a bunch of data, one or more pieces of data that are associated with the type. And interface type just specifies some method signatures. So no data is specified, just the methods. And even the methods, the implementations are abstracted. You don't have implementations, you just have the signatures of the methods. So that's the difference between the two. But remember that when you give an interface, interface eventually gets mapped to a concrete type, we'll see that in a second. So an interface value, when you create an interface you declare an interface type, you make a value of that type. You can treat it like other values, ints, floats and all this, you can make a variable of that type. So I can make a variable of the type of a particular interface, like my shape 2D, I can make a variable of that type. Now an interface value, the value of an interface like that has two components. First, there's dynamic type, second there's dynamic value. So dynamic type, is a concrete type that is assigned to. So the dynamic value though is actually the value of that dynamic type. So the dynamic type is just the type which it's associated to. So to be more specific, let's say we're talking about shape 2D, that's my interface, right. This interface, there are several concrete types which satisfy my interface, like rectangle, that satisfies my interface, triangle satisfies my interface. Now when I make my interface variable and I give it a value, that value has gotta be mapped to a concrete type. Maybe it's mapped to a rectangle, or a triangle, or something like that. And that rectangle, triangle, whatever it is, it's going to have a value. So the rectangle might have some points in it, and the triangle might have some points in it. So there's a dynamic type which is the type of the concrete type that the interface value is assigned to. And the dynamic value is the value of that dynamic type. So an interface value is actually a pair, the dynamic type together with the dynamic value. This probably will become more clear within the next lesson given a bit of an example. So defining an interface type, so we got this type speaker interface speaker interface. And all we define in there is the speak method. Which takes the arguments and returns no values, so very simple interface. So that's our interface type at the top. Now then I also defined my dog type, okay. And it's a type called dog, its structure, and it's got just a string in there, okay. The name of the dog let's say, name, it's called name. So it just got, that's my whole dog type. And what I'm going to do is I'm going to make this dog type, make it satisfy my speaker interface. So I declare a function called Speak, it's receiver type is Dog. And it just prints the name of the dog, d.name, so that's what the dog speaks. So now, Dog is a type that satisfies the Speaker interface. In my main the first thing I do is I declare a speaker. So an s1, s1 is a variable and is going to actually have a speaker value. So it's a speaker type, it's going to be a speaker value, right. So s1 is an interface value. Next I declare a dog, [LAUGH] a d1, it's going to be my dog type. It's going to have a name equal to Brian. Now then I can say s1 equals d1. Now, that is legal because the dog type satisfies the s1 interface. So S1 can be a dog because it satisfies the interface, so I can say s1 is equal to d1. So now s1, s1 is a speaker type, its concrete type that is assigned to is d1. That is the concrete object that it's assigned to, which is the concrete type is going to be the dynamic type is going to be the dog type. And the value is going to be the dog value, which he's name is Brian. And then I can say s1.speak, and it'll call the speak of the dog, which we'll just print out Brian. So the Dynamic type in this case of s1 is Dog, is a Dog type. And the Dynamic value is d1 which contains that name Brian, okay. So this s1 which is a speaker object, it is, sorry, it's a speaker object which is an interface, it is a pair. The Dynamic type Dog, that's the type, and Dynamic value, Dynamic value, which is d1 in this case. Which has this Dog name, name Brian, that's all it has in it.
Play video starting at :5:18 and follow transcript5:18
Okay, so an interface, just to repeat, has dynamic type and dynamic value. Now interface can have a Nil Dynamic Value, meaning no dynamic value. It can have a type, a dynamic type but not a dynamic value. So let me give you an example of that. [COUGH] We got a variable, s1 is the speaker, okay. Then I have my dog d1 and I make it point to a dog, *Dog, then I say s1=d1. Now when I do that, I'm assigning s1 to d1, but d1, it's not a concrete object it's type is Dog, or *Dog, it's pointing to a Dog. But it doesn't have any data in it, okay. So remember Dog has this data, this name, which is a string. But d1 is a pointer to a Dog, so it's not an actual Dog, it doesn't have the data in it. Okay, so d1 has no concrete value at this point. But it have a type, okay, it's associated with a dog, it's appointed to a dog. So what that means is when I do that assignment s1 equals d1. S1 has a dynamic type, dog, or dog pointer, but has no dynamic value because d1 doesn't have a dynamic value yet, right. because d1 is a pointer to a dog, it doesn't actually have dog information in it, namely the name, okay. So this is a situation where you got an interface that has a nil dynamic value. Nil means nothing, it's sort of the empty end goal. So it has a nil dynamic value but it has a dynamic type.
Play video starting at :6:50 and follow transcript6:50
And this is legal, to have a dynamic type but no dynamic value is legal. So when you have that situation, when you have an interface like that, with a dynamic type but no dynamic value, you can still call the methods of s1. So in this case, s1, its method is speak, right. That's the method that's defined in the interface. And Dog, or at least it's specified in the interface. And then Dog defines that method, right. So when I say Dog defines that method, there's a method Dog who's receiver type is Dog, method speak who's receiver type is Dog. And that method is fully specified. Now this s1, it has a dynamic type. The fact that it has a dynamic type means that the compiler knows that when you call Speak, call that speak method on s1. It could look at the type and say, the type is dog, the dynamic type is dog. So I know that the method implementation that I want is dog method implementation. So it can call that function, that method speak even without having a dynamic value, all it needs to know is the dynamic type. The dynamic type is enough information to go find which implementation Speak you want to use. Now, it would be wise inside the speak function to check, to see if the variable has a dynamic value or not. But the point though, is that you can make the call even without a dynamic value, all you need is a dynamic type. So we take a look over here, we got this function Dog, Speak rather, and its receiver is Dog. And notice inside the function it says if d == nil then it prints ("<noise>") some generic thing, else it prints (d.name), it prints the dog's name. Now what that does is it checks saying d == nil</noise> It checks look, does this have a dynamic value or not? If it doesn't have a dynamic value and d equals nil then it just does what it says there. Prints noise because it doesn't have a dynamic value yet, prints something generic. L, so if it does have a value then it knows it can actually access dname, d.name, and so it prints out the name. And then the rest of the code maybe that would appear inside a main or something like that, which I'm not drawing here. But so I declare this speaker as one, I declare the Dog pointer d1. I set s1 to d1 so now s1 has a dynamic type but no dynamic value. And then I can call s1.speak and it works, right. A class one does speak even without the dynamic value because it can figure out, the compiler can figure out, I see s1 is mapped to d1 which is a dog. So I can find the dog, the method is bigger that is associated with dog that I had to find up above, so this is actually legal. So the point of all this is it legal to have a speaker, sorry an interface, with a dynamic type but not a dynamic value. And in that situation, you can still call the method of that interface, so it is legal to do that. Now we'll be wise like we do here to check inside the method if the dynamic value is nil or not, right. Because you might want to do something, for instance if we didn't do this check, this is where we say if d equals nil. If we didn't do that check, we might try to print D.name, even though D was nil, and that would throw an error at run time. So we don't want to, it's probably wise to check it but it's allowed. This is a legal state, to have a dynamic type but no dynamic value. Now on the other hand, people use a term nil interface value, this describes an interface with a nil dynamic type. So not only does it not have a dynamic value, it doesn't have a dynamic type, and that's a different situation. [COUGH] In that situation, when you don't even have the dynamic type, then you cannot call the methods on that interface. Because without the dynamic type, you can't know which method you are referring to. So for instance, here If at the top example I got the speaker s1 dog d1 and I say s1 equals d1. So it has a dynamic type but no dynamic value. So the compiler configure out if I go to call speak It would be able to figure out, I see, it's the dog's speak., the one whose receiver type is dog. But if I have a nil dynamic type, so if I just say VAR S1 speaker and leave it at that. Then I don't have a dynamic type yet because I haven't assigned s1 to anything, right. So s1 is just sitting there with no dynamic type, no dynamic value. And in that state there's no actual method to call. He tried to call a speak on that, it would throw an error because there's no method implementation. Remember to interface doesn't specify the method, it doesn't give the implementation of the method. It specifies just the name and the arguments and the return value, but it doesn't actually define the method. So if you just say var s1 Speaker, there's no method that it is associated with. There's no speak method associated with s1, so this would throw an error. So the point here is summarized that if you have no dynamic type and no dynamic value on interface, then you can't call the methods of the interface, thank you.

# M4.2.1 - Using Interfaces
Thank you. Thank you. So interfaces, we've talked about them. And one thing we want to talk about now is a little bit of how to use them. So what are they used for, language-wise? And in language, why would you need an interface? And I already said, interfaces, they express some sort of a conceptual similarity between different types. So the idea is that if two types satisfy an interface, then they must be similar in some way that is important to the application. So one common, sort of, practical thing that you would use an interface for, is when you need a function, you want to write a function which takes multiple types as a parameter. So specifically, normally, a function, it takes, say, it takes an integer as its arguments, right? It can only take an integer. But what if you want to take an integer or a float? Something like this, maybe a integer, a float or a string, right? You want it to take multiple types. In different types, it'll do different things, but you want it to be able to take different types. You can use an interface for that. So giving an example, say I've got a function, foo ( ), and it's gotta take a parameter. And this parameter, it could be either type X or type Y. And I'm talking very generically now. I'll give you a concrete example in the next slide, but so I got this foo. It's going to take a parameter which is type X or type Y. I want it to take either type. So the way I can do that is I can define an interface called Z.
Play video starting at :1:23 and follow transcript1:23
And X as a parameter can be, the type it can be, in interface type Z.
Play video starting at :1:29 and follow transcript1:29
Then I define X and Y to satisfy Z. Right, so, X and Y are both satisfying the interface Z. Then foo(), since it can take anything that satisfies interface Z, it can take X and Y as its arguments. So this is a common way to use an interface. And basically, an interface in this way, it sort of generalizes, right? It hides the details of the differences between the types. It's like look, these two types are similar in the way that's important to me. And so your function could just take the interface. It needs to take anything that is similar in that way.
Play video starting at :2:4 and follow transcript2:04
So, to be a little bit more specific, I made up a problem about a pool in a yard, right? So, I have a backyard, and I want to put a pool in my yard. But the pool, before I can put the pool in the yard, it needs to fit in my yard. And it needs to be fenced, because I don't want my kids to fall into the pool, so I need fencing around the pool. And it needs to fit in the yard. So to fit in the yard, the total area this pool needs to be limited. Less than the area of the backyard.
Play video starting at :2:30 and follow transcript2:30
Also to fence it, I only have so much fence, because fence cost money. I only have a limited amount of fence. So the perimeter of this thing has to be limited to within some limit, depending on how much I can afford. So I need to determine if a particular pool shape satisfies this criteria, because I'm trying to go through a bunch of different pool shapes. And I want to pick one that satisfies these criterias. It's sort of small enough that it can fit in the yard. And also the perimeter's small enough so that I can afford to fence it. So I'm going to write this function called FitInYard (). And this is going to return a boolean. So it takes a shape as an argument. Some shape, maybe I got some triangular shape, I was pass that to FitInYard, and it returns true, if the shape satisfies the criteria. So if the area is small enough, and the pool is small enough, then it says true. If I pass it a shape like rectangle and it's a big rectangle and it doesn't fit in my yard then it will return false, okay? So that's what FitInYard is. Now the thing about fit in yard is it's got to take a shape as an argument. But I want it to take any shape as an argument. I don't care if it's a triangle, circle, square, rectangle, whatever, it can be any shape. I should take it as an argument. But I have to be able to compute the area and compute the perimeter, okay? So not any shape, its got to be a shape whose area and perimeter I can compute. So let's say the idea is should take rectangles, triangles, whatever. But a valid shape has to have an area method and a perimeter method, right? So if the shape, if I can't compute the area, then I won't be able to tell if it fits in my yard. Say it's a sphere or something, right? There's no area, it's a 3D shape, that's a 3D object, I can't compute area of a thing like that, right? So, that is not a valid shape that I want to try to fit in my yard.
Play video starting at :4:15 and follow transcript4:15
So, any shape that has area and perimeter, that's okay with me.
Play video starting at :4:20 and follow transcript4:20
So what I can do is I can define this interface for shapes that have the area and perimeter. So I make my Shape2D interface. We already talked about this. But I make my Shape2D interface. It specifies area and perimeter, which return float64. Then I can make my types, triangle type, rectangle type, whatever types I want. And as long as these types, I don't care how they define what data's inside them, as long as they have methods that use them as receiver types. That it has area method and perimeter method. So, a triangle, you got area that has triangle as a receiver method and also perimeter. Same thing for rectangles, it's got an area and a perimeter. As long as they have area and parameter, I should be able to take this as an argument. So they satisfy this interface Shape2D. So in my FitInYard implementation, you can see that the argument that it takes is called s, and its type is the interface type, Shape2D. So what that means is that this argument could be any type that satisfies that Shape2D interface. Like rectangle, triangle, whatever the types are. And it returns a boolean and all the function does is very simple. Just says if s.Area is less than 100, let's say 100 is the size of my backyard, right? And as our perimeter is less than 100, because that's all the fence I could afford, then return true, else return false. So a valid argument to this is any type that satisfies the shape to the interface.
Play video starting at :5:57 and follow transcript5:57
Now the empty interface is standard interfaces predefined and it just specifies no methods. So that means that any type can actually satisfy that interface. And what you use it for is when you want to have a function argument be any type. You don't want to restrict it at all in terms of the type that this function can accept. Then you just make it's type the empty interface. So as an example, we got this function PrintMe. And its val argument is the empty interface. That's how you specify the empty interface that I haven't read. So that means that val can just be any type. And all this does is just print it. So it will print any type you give it. You give it an int, float, string, whatever, it will just print that to the screen.
Play video starting at :6:43 and follow transcript6:43
Thank you.

# M4.2.2 - Type Assertions
Module four, Interfaces for Abstraction. Topic 2.2, Type Assertions.
Play video starting at ::5 and follow transcript0:05
So a lot of the point of an interface is to conceal differences between types. So if you think about it, an interface can hide the differences between two types. It basically highlights the two similarities. So while in this fit and yard implementation, there are rectangles and there are triangles. But from the inside fit in yard, they're all treated the same, right? As long as they both satisfy Shape2D, I can call s.Area, s.Perimeter, right? So what you're doing is, what interface allow you to do is to treat different types that have some similarities, some similar methods, treat them the same. All right, so you are hiding differences by using interfaces. But sometimes you need to disambiguate, sometimes you need to treat different types in different ways, okay? So sometimes, like in this function, we don't, right? We can just say s.Area, s.Perimeter. We treat them exactly the same because they have the same methods. But sometimes you do need to differentiate based on the type. You need to be able to figure out what is the concrete type, right? So in this example, s, since you're just calling area and perimeter, it doesn't matter exactly what the concrete type is, right? The concrete type could be rectangle, it could be triangle. It doesn't matter, either way area and perimeter do what you think. So in this case, the concrete type that underlies the interface value, that doesn't matter, okay? But there are definitely cases where the concrete type matters. In those cases, you're going to have to expose those type differences. So you're going to have to take this interface, which is hiding the differences between the types, and peel it apart again, and say okay, actually, this is really a rectangle, this is really a triangle. So situations like that might be a graphics program, okay? So I got my graphics program which I've used many times, but in my graphics program, this time I want to write a function called DrawShape. And it should draw any shape. So I want to be able to pass it as an argument any two dimensional shape. So I declare it sort of the top line I'm showing right there, func DrawShape. It takes Shape2D, that's the type of it's argument, Shape2D. So it can take any two dimensional shape as an argument. So that's good, right? I've used my interface to generalize and to hide the differences between the types, rectangle, triangle, circle, doesn't matter, for passing it as an argument to draw shape anyway. Now, inside DrawShape, though, in this case, I'm going to have to disambiguate. I'm going to have to determine this s, is it a rectangle, is it a triangle, what is it? Because maybe in the underlying API there's some kind of drawing functions that I'm using in this API, right? And the underlying drawing functions, they actually are specific to the type of shaping drawing. So for instance, maybe the underlying API gives me a draw rectangle, DrawRect, right? And then another draw triangle, and a draw circle, and so on, which is not uncommon in these drawing APIs, right? So you got draw rectangle, draw triangle, draw circle, all those. Now, these API functions, my DrawShape is going to have call these, right? When it wants to draw a rectangle, it's going to have to call DrawRectangle. DrawTriangle to draw triangle. And these underlying API functions, they don't take just any shape. They won't take Shape2D. DrawRect only takes rectangles. DrawTriangle only takes triangles. And so on. So this is the case where I want to use my interface so my DrawShape can take any argument, any type of reasonable shape. But inside my DrawShape, I'm going to have to differentiate. I'm going to say, look, if you're a rectangle, call DrawRect. If you're a triangle, call DrawTriangle, and so on. So in this case, inside DrawShape, I'm going to have to determine the concrete type that s is based on, that the shape is based on.
Play video starting at :3:47 and follow transcript3:47
So for that, I use what's called a type assertion. So type assertions can be used to disambiguate between the different concrete types that actually satisfy a particular interface. And you can see that here with DrawShape. It needs to actually disambiguate. So if it's a rectangle that's being passed, it needs to call DrawRect. If it's a triangle, it needs to call it DrawTraingle. So you can see us doing that here. At the top, you've got that first type assertion, where it says rect, ok:=, so that will return a rectangle, if the s is actually a rectangle. So if ok is true, and it found a rectangle, it will call DrawRect with that rectangle. Otherwise, the next type assertion actually checks to see if the type of the interface of s is a triangle. So it says, tri, ok:= s.(Triangle) this time. And so, ok will be true if s is actually a triangle. And in that case, tri is going to equal that triangle. And so, you call DrawTriangle with a triangle. So either way, we use this type assertion to disambiguate, to determine the actual underlying concrete type for this Shape2D interface.
Play video starting at :5:4 and follow transcript5:04
Now, another way to do this sort of a common thing that you need to do is what we just did in the last slide, we went down a list of possible types. So rectangle and triangle in this case. But note that an interface can actually be satisfied by many different types. There's an interface that's satisfied by 10 different types, you might need to disambiguate all 10. So to run down the list. If you're this type, then do this. If you're that type, then do that, and so on. And so, there's a switch construct type switch which is just for that purpose. So you got one case for every different type that you need to deal with. So in this case, you got two cases, case Rectangle, case Triangle. And in each case, case Rectangle draws the rectangle, case Triangle draws the triangle. But right before that, you start with the switch. So notice the type Type assertion says s.type. In parentheses you just say type, the generic word type. And so, what happens is sh will be whatever the, it'll be the concrete type that s represents. So if s is actually a rectangle, then sh will be that rectangle, right? If s is a triangle, then sh will be that triangle. And you'll hit the appropriate case. So if sh is a rectangle, then you'll execute the case rectangle. If sh is a triangle, then you'll execute the case triangle. So this is just a more convenient way to sort of run down a list to disambiguate a whole set of types that all satisfy a particular interface.
Play video starting at :6:36 and follow transcript6:36
Thank you.

# M4.2.3 - Error Handling
Module 4, Interfaces for Abstraction, Topic 2.3, Error Handling. So I just want to show a common use of interfaces in Go.
Play video starting at ::10 and follow transcript0:10
The Error Interface. So there are a lot of different Go functions that are built into packages, which return errors. And when I say return errors, what they do is they return whatever they're supposed to return, and then their second return value is an error. An error interface. So and we see it defined over here. The error interface just is any type that satisfies this interface, and error interface just specifies that you have to have a method called, error, which prints the error message essentially which prints something, some text that's useful. So under correct operation, the error return might be nil, so for instance, let's say, I want to open a file. If it opens the file correctly, it'll return nil for the error, and there's no problem. But if the error actually has a value, then you'll probably print the error, and it'll call its error method, which will successfully print the error. So show you an example of that. So basically the idea is, when you, this happens, there a lot of different Go language function like this, which return error as the second argument, okay? And so, when that happens, you should check that error, after the call, and handle it if you need to. So you can see on the top line, we're opening a file. So os.open, open the file by that name, and it returns two things. One is the file F, and the second thing is an error, if an error exist. So then, right after that, for safety's sake, you should check the error. So if error not equal to nil, so if it's equal to nil, you're fine, you go on. If it's not equal to nil, then, do a print that sort of the most obvious thing to do to handle the error, is just to print it. So you println(err) and return.
Play video starting at :1:57 and follow transcript1:57
So printing the error, the format package, the fmt package, which println is a part of. That package will call the error method of the error to generate the string, and print that string. And so, this is sort of the generic way of handling errors in Go. It's a very common way to handle errors in Go.
Play video starting at :2:18 and follow transcript2:18
Thank you.