# M4.1.1 - Polymorphism

## Polymorphism
- Polymorphism: ability for an object to have different forms depending on the context.
    - a function or method can be different depending on object type
    - Ex. Area function. For rectange or triangle it could have the same name but it would do two different operations depending on the object type
    - High level of abstraction. Although the way of getting area is differnt in formula, it is still returning the area of the shape.
    - High level the return is identical. Low level (what the method does to get the return value) is different depending on type

Traditional OOP: inheritance through parent and child classes
    - Subclass inherits the methods/data of the superclass
    - Example: Speaker superclass
        - Speak() method, prints "<noise>"
    - Subclass Cat and Dog
        - Also have the Speak() method
    - Cat and Dog are different forms of speaker

    - Overriding
        - Subclass redefines a method inherited from the superclass
        - Example: Speaker, Cat, Dog
            - Speaker Speak() prints "<noise>"
            - Cat Speak() prints "meow"
            - Dog Speak() prints "woof"
        - Subclass will redefine the speak value -> Speak will be polymorphic with this inheritance and overriding
            - Different implementations for each class
            - Same signature (name, params, return)


# M4.1.2 - Interfaces

## Interfaces
- Interface: Set of method signatures
    - Signatures: Name, parameters, return values and types
    - Helps with polymorphism
    - Used to express conceptual similarity between types
- Example Shape2D interface
    - All 2D shapes must have Area() and Perimeter()
    - Any type with these two methods would be considered a 2DShape
    - Does not define the method, but gives the signature for the methods
### Satisfying an Interface
    - Type satisfies an interface if type defines all methods specified in the interface
        - Same method signatures
    - Rectangle and Triangle types satisfy the Shape2D interface
        - Must have Area() and Perimeter() methods
        - Rectangle and Triangle can have other methods and data, but as long as they have the Area and Perimeter, they will be considered 2DShapes, they satisfy the interface

### Defining an Interface Type
```
type Shape2D interface {
    Area() float64
    Perimeter() float64
}
type Triangle {...}
func (t Triangle) Area() float64{...}
func (t Triangle) Perimeter() float64{...}
```
- Triangle type satisfies the Shape2D interface
- No need to state it explicitly
- In Go you do not need to explicitly say that Triangle satisfied the Shape2D interface

# M4.1.3 - Interface vs. Concrete Types
Module 4: Interfaces for Abstraction, Topic 1.3: Interface versus Concrete Types. So concrete types and interface types are fundamentally different. A concrete type is a regular type, it specifies the exact representation of the data and the methods, data specifically, but also methods that are used in the type of the receiver type. So, they're fully specified, and it has complete implementations of the method, of all the methods. So any methods that use this type as a receiver type, they're completely specified. But the first thing is sort of a big difference between interface types and concrete types is that the exact representation of the data is in there. So if you have a concrete type, it's going to have a bunch of data, one or more pieces of data that are associated with the type. And interface type just specifies some method signatures. So no data is specified, just the methods. And even the methods, the implementations are abstracted. You don't have implementations, you just have the signatures of the methods. So that's the difference between the two. But remember that when you give an interface, interface eventually gets mapped to a concrete type, we'll see that in a second. So an interface value, when you create an interface you declare an interface type, you make a value of that type. You can treat it like other values, ints, floats and all this, you can make a variable of that type. So I can make a variable of the type of a particular interface, like my shape 2D, I can make a variable of that type. Now an interface value, the value of an interface like that has two components. First, there's dynamic type, second there's dynamic value. So dynamic type, is a concrete type that is assigned to. So the dynamic value though is actually the value of that dynamic type. So the dynamic type is just the type which it's associated to. So to be more specific, let's say we're talking about shape 2D, that's my interface, right. This interface, there are several concrete types which satisfy my interface, like rectangle, that satisfies my interface, triangle satisfies my interface. Now when I make my interface variable and I give it a value, that value has gotta be mapped to a concrete type. Maybe it's mapped to a rectangle, or a triangle, or something like that. And that rectangle, triangle, whatever it is, it's going to have a value. So the rectangle might have some points in it, and the triangle might have some points in it. So there's a dynamic type which is the type of the concrete type that the interface value is assigned to. And the dynamic value is the value of that dynamic type. So an interface value is actually a pair, the dynamic type together with the dynamic value. This probably will become more clear within the next lesson given a bit of an example. So defining an interface type, so we got this type speaker interface speaker interface. And all we define in there is the speak method. Which takes the arguments and returns no values, so very simple interface. So that's our interface type at the top. Now then I also defined my dog type, okay. And it's a type called dog, its structure, and it's got just a string in there, okay. The name of the dog let's say, name, it's called name. So it just got, that's my whole dog type. And what I'm going to do is I'm going to make this dog type, make it satisfy my speaker interface. So I declare a function called Speak, it's receiver type is Dog. And it just prints the name of the dog, d.name, so that's what the dog speaks. So now, Dog is a type that satisfies the Speaker interface. In my main the first thing I do is I declare a speaker. So an s1, s1 is a variable and is going to actually have a speaker value. So it's a speaker type, it's going to be a speaker value, right. So s1 is an interface value. Next I declare a dog, [LAUGH] a d1, it's going to be my dog type. It's going to have a name equal to Brian. Now then I can say s1 equals d1. Now, that is legal because the dog type satisfies the s1 interface. So S1 can be a dog because it satisfies the interface, so I can say s1 is equal to d1. So now s1, s1 is a speaker type, its concrete type that is assigned to is d1. That is the concrete object that it's assigned to, which is the concrete type is going to be the dynamic type is going to be the dog type. And the value is going to be the dog value, which he's name is Brian. And then I can say s1.speak, and it'll call the speak of the dog, which we'll just print out Brian. So the Dynamic type in this case of s1 is Dog, is a Dog type. And the Dynamic value is d1 which contains that name Brian, okay. So this s1 which is a speaker object, it is, sorry, it's a speaker object which is an interface, it is a pair. The Dynamic type Dog, that's the type, and Dynamic value, Dynamic value, which is d1 in this case. Which has this Dog name, name Brian, that's all it has in it.
Play video starting at :5:18 and follow transcript5:18
Okay, so an interface, just to repeat, has dynamic type and dynamic value. Now interface can have a Nil Dynamic Value, meaning no dynamic value. It can have a type, a dynamic type but not a dynamic value. So let me give you an example of that. [COUGH] We got a variable, s1 is the speaker, okay. Then I have my dog d1 and I make it point to a dog, *Dog, then I say s1=d1. Now when I do that, I'm assigning s1 to d1, but d1, it's not a concrete object it's type is Dog, or *Dog, it's pointing to a Dog. But it doesn't have any data in it, okay. So remember Dog has this data, this name, which is a string. But d1 is a pointer to a Dog, so it's not an actual Dog, it doesn't have the data in it. Okay, so d1 has no concrete value at this point. But it have a type, okay, it's associated with a dog, it's appointed to a dog. So what that means is when I do that assignment s1 equals d1. S1 has a dynamic type, dog, or dog pointer, but has no dynamic value because d1 doesn't have a dynamic value yet, right. because d1 is a pointer to a dog, it doesn't actually have dog information in it, namely the name, okay. So this is a situation where you got an interface that has a nil dynamic value. Nil means nothing, it's sort of the empty end goal. So it has a nil dynamic value but it has a dynamic type.
Play video starting at :6:50 and follow transcript6:50
And this is legal, to have a dynamic type but no dynamic value is legal. So when you have that situation, when you have an interface like that, with a dynamic type but no dynamic value, you can still call the methods of s1. So in this case, s1, its method is speak, right. That's the method that's defined in the interface. And Dog, or at least it's specified in the interface. And then Dog defines that method, right. So when I say Dog defines that method, there's a method Dog who's receiver type is Dog, method speak who's receiver type is Dog. And that method is fully specified. Now this s1, it has a dynamic type. The fact that it has a dynamic type means that the compiler knows that when you call Speak, call that speak method on s1. It could look at the type and say, the type is dog, the dynamic type is dog. So I know that the method implementation that I want is dog method implementation. So it can call that function, that method speak even without having a dynamic value, all it needs to know is the dynamic type. The dynamic type is enough information to go find which implementation Speak you want to use. Now, it would be wise inside the speak function to check, to see if the variable has a dynamic value or not. But the point though, is that you can make the call even without a dynamic value, all you need is a dynamic type. So we take a look over here, we got this function Dog, Speak rather, and its receiver is Dog. And notice inside the function it says if d == nil then it prints ("<noise>") some generic thing, else it prints (d.name), it prints the dog's name. Now what that does is it checks saying d == nil</noise> It checks look, does this have a dynamic value or not? If it doesn't have a dynamic value and d equals nil then it just does what it says there. Prints noise because it doesn't have a dynamic value yet, prints something generic. L, so if it does have a value then it knows it can actually access dname, d.name, and so it prints out the name. And then the rest of the code maybe that would appear inside a main or something like that, which I'm not drawing here. But so I declare this speaker as one, I declare the Dog pointer d1. I set s1 to d1 so now s1 has a dynamic type but no dynamic value. And then I can call s1.speak and it works, right. A class one does speak even without the dynamic value because it can figure out, the compiler can figure out, I see s1 is mapped to d1 which is a dog. So I can find the dog, the method is bigger that is associated with dog that I had to find up above, so this is actually legal. So the point of all this is it legal to have a speaker, sorry an interface, with a dynamic type but not a dynamic value. And in that situation, you can still call the method of that interface, so it is legal to do that. Now we'll be wise like we do here to check inside the method if the dynamic value is nil or not, right. Because you might want to do something, for instance if we didn't do this check, this is where we say if d equals nil. If we didn't do that check, we might try to print D.name, even though D was nil, and that would throw an error at run time. So we don't want to, it's probably wise to check it but it's allowed. This is a legal state, to have a dynamic type but no dynamic value. Now on the other hand, people use a term nil interface value, this describes an interface with a nil dynamic type. So not only does it not have a dynamic value, it doesn't have a dynamic type, and that's a different situation. [COUGH] In that situation, when you don't even have the dynamic type, then you cannot call the methods on that interface. Because without the dynamic type, you can't know which method you are referring to. So for instance, here If at the top example I got the speaker s1 dog d1 and I say s1 equals d1. So it has a dynamic type but no dynamic value. So the compiler configure out if I go to call speak It would be able to figure out, I see, it's the dog's speak., the one whose receiver type is dog. But if I have a nil dynamic type, so if I just say VAR S1 speaker and leave it at that. Then I don't have a dynamic type yet because I haven't assigned s1 to anything, right. So s1 is just sitting there with no dynamic type, no dynamic value. And in that state there's no actual method to call. He tried to call a speak on that, it would throw an error because there's no method implementation. Remember to interface doesn't specify the method, it doesn't give the implementation of the method. It specifies just the name and the arguments and the return value, but it doesn't actually define the method. So if you just say var s1 Speaker, there's no method that it is associated with. There's no speak method associated with s1, so this would throw an error. So the point here is summarized that if you have no dynamic type and no dynamic value on interface, then you can't call the methods of the interface, thank you.

# M4.2.1 - Using Interfaces
Thank you. Thank you. So interfaces, we've talked about them. And one thing we want to talk about now is a little bit of how to use them. So what are they used for, language-wise? And in language, why would you need an interface? And I already said, interfaces, they express some sort of a conceptual similarity between different types. So the idea is that if two types satisfy an interface, then they must be similar in some way that is important to the application. So one common, sort of, practical thing that you would use an interface for, is when you need a function, you want to write a function which takes multiple types as a parameter. So specifically, normally, a function, it takes, say, it takes an integer as its arguments, right? It can only take an integer. But what if you want to take an integer or a float? Something like this, maybe a integer, a float or a string, right? You want it to take multiple types. In different types, it'll do different things, but you want it to be able to take different types. You can use an interface for that. So giving an example, say I've got a function, foo ( ), and it's gotta take a parameter. And this parameter, it could be either type X or type Y. And I'm talking very generically now. I'll give you a concrete example in the next slide, but so I got this foo. It's going to take a parameter which is type X or type Y. I want it to take either type. So the way I can do that is I can define an interface called Z.
Play video starting at :1:23 and follow transcript1:23
And X as a parameter can be, the type it can be, in interface type Z.
Play video starting at :1:29 and follow transcript1:29
Then I define X and Y to satisfy Z. Right, so, X and Y are both satisfying the interface Z. Then foo(), since it can take anything that satisfies interface Z, it can take X and Y as its arguments. So this is a common way to use an interface. And basically, an interface in this way, it sort of generalizes, right? It hides the details of the differences between the types. It's like look, these two types are similar in the way that's important to me. And so your function could just take the interface. It needs to take anything that is similar in that way.
Play video starting at :2:4 and follow transcript2:04
So, to be a little bit more specific, I made up a problem about a pool in a yard, right? So, I have a backyard, and I want to put a pool in my yard. But the pool, before I can put the pool in the yard, it needs to fit in my yard. And it needs to be fenced, because I don't want my kids to fall into the pool, so I need fencing around the pool. And it needs to fit in the yard. So to fit in the yard, the total area this pool needs to be limited. Less than the area of the backyard.
Play video starting at :2:30 and follow transcript2:30
Also to fence it, I only have so much fence, because fence cost money. I only have a limited amount of fence. So the perimeter of this thing has to be limited to within some limit, depending on how much I can afford. So I need to determine if a particular pool shape satisfies this criteria, because I'm trying to go through a bunch of different pool shapes. And I want to pick one that satisfies these criterias. It's sort of small enough that it can fit in the yard. And also the perimeter's small enough so that I can afford to fence it. So I'm going to write this function called FitInYard (). And this is going to return a boolean. So it takes a shape as an argument. Some shape, maybe I got some triangular shape, I was pass that to FitInYard, and it returns true, if the shape satisfies the criteria. So if the area is small enough, and the pool is small enough, then it says true. If I pass it a shape like rectangle and it's a big rectangle and it doesn't fit in my yard then it will return false, okay? So that's what FitInYard is. Now the thing about fit in yard is it's got to take a shape as an argument. But I want it to take any shape as an argument. I don't care if it's a triangle, circle, square, rectangle, whatever, it can be any shape. I should take it as an argument. But I have to be able to compute the area and compute the perimeter, okay? So not any shape, its got to be a shape whose area and perimeter I can compute. So let's say the idea is should take rectangles, triangles, whatever. But a valid shape has to have an area method and a perimeter method, right? So if the shape, if I can't compute the area, then I won't be able to tell if it fits in my yard. Say it's a sphere or something, right? There's no area, it's a 3D shape, that's a 3D object, I can't compute area of a thing like that, right? So, that is not a valid shape that I want to try to fit in my yard.
Play video starting at :4:15 and follow transcript4:15
So, any shape that has area and perimeter, that's okay with me.
Play video starting at :4:20 and follow transcript4:20
So what I can do is I can define this interface for shapes that have the area and perimeter. So I make my Shape2D interface. We already talked about this. But I make my Shape2D interface. It specifies area and perimeter, which return float64. Then I can make my types, triangle type, rectangle type, whatever types I want. And as long as these types, I don't care how they define what data's inside them, as long as they have methods that use them as receiver types. That it has area method and perimeter method. So, a triangle, you got area that has triangle as a receiver method and also perimeter. Same thing for rectangles, it's got an area and a perimeter. As long as they have area and parameter, I should be able to take this as an argument. So they satisfy this interface Shape2D. So in my FitInYard implementation, you can see that the argument that it takes is called s, and its type is the interface type, Shape2D. So what that means is that this argument could be any type that satisfies that Shape2D interface. Like rectangle, triangle, whatever the types are. And it returns a boolean and all the function does is very simple. Just says if s.Area is less than 100, let's say 100 is the size of my backyard, right? And as our perimeter is less than 100, because that's all the fence I could afford, then return true, else return false. So a valid argument to this is any type that satisfies the shape to the interface.
Play video starting at :5:57 and follow transcript5:57
Now the empty interface is standard interfaces predefined and it just specifies no methods. So that means that any type can actually satisfy that interface. And what you use it for is when you want to have a function argument be any type. You don't want to restrict it at all in terms of the type that this function can accept. Then you just make it's type the empty interface. So as an example, we got this function PrintMe. And its val argument is the empty interface. That's how you specify the empty interface that I haven't read. So that means that val can just be any type. And all this does is just print it. So it will print any type you give it. You give it an int, float, string, whatever, it will just print that to the screen.
Play video starting at :6:43 and follow transcript6:43
Thank you.

# M4.2.2 - Type Assertions
Module four, Interfaces for Abstraction. Topic 2.2, Type Assertions.
Play video starting at ::5 and follow transcript0:05
So a lot of the point of an interface is to conceal differences between types. So if you think about it, an interface can hide the differences between two types. It basically highlights the two similarities. So while in this fit and yard implementation, there are rectangles and there are triangles. But from the inside fit in yard, they're all treated the same, right? As long as they both satisfy Shape2D, I can call s.Area, s.Perimeter, right? So what you're doing is, what interface allow you to do is to treat different types that have some similarities, some similar methods, treat them the same. All right, so you are hiding differences by using interfaces. But sometimes you need to disambiguate, sometimes you need to treat different types in different ways, okay? So sometimes, like in this function, we don't, right? We can just say s.Area, s.Perimeter. We treat them exactly the same because they have the same methods. But sometimes you do need to differentiate based on the type. You need to be able to figure out what is the concrete type, right? So in this example, s, since you're just calling area and perimeter, it doesn't matter exactly what the concrete type is, right? The concrete type could be rectangle, it could be triangle. It doesn't matter, either way area and perimeter do what you think. So in this case, the concrete type that underlies the interface value, that doesn't matter, okay? But there are definitely cases where the concrete type matters. In those cases, you're going to have to expose those type differences. So you're going to have to take this interface, which is hiding the differences between the types, and peel it apart again, and say okay, actually, this is really a rectangle, this is really a triangle. So situations like that might be a graphics program, okay? So I got my graphics program which I've used many times, but in my graphics program, this time I want to write a function called DrawShape. And it should draw any shape. So I want to be able to pass it as an argument any two dimensional shape. So I declare it sort of the top line I'm showing right there, func DrawShape. It takes Shape2D, that's the type of it's argument, Shape2D. So it can take any two dimensional shape as an argument. So that's good, right? I've used my interface to generalize and to hide the differences between the types, rectangle, triangle, circle, doesn't matter, for passing it as an argument to draw shape anyway. Now, inside DrawShape, though, in this case, I'm going to have to disambiguate. I'm going to have to determine this s, is it a rectangle, is it a triangle, what is it? Because maybe in the underlying API there's some kind of drawing functions that I'm using in this API, right? And the underlying drawing functions, they actually are specific to the type of shaping drawing. So for instance, maybe the underlying API gives me a draw rectangle, DrawRect, right? And then another draw triangle, and a draw circle, and so on, which is not uncommon in these drawing APIs, right? So you got draw rectangle, draw triangle, draw circle, all those. Now, these API functions, my DrawShape is going to have call these, right? When it wants to draw a rectangle, it's going to have to call DrawRectangle. DrawTriangle to draw triangle. And these underlying API functions, they don't take just any shape. They won't take Shape2D. DrawRect only takes rectangles. DrawTriangle only takes triangles. And so on. So this is the case where I want to use my interface so my DrawShape can take any argument, any type of reasonable shape. But inside my DrawShape, I'm going to have to differentiate. I'm going to say, look, if you're a rectangle, call DrawRect. If you're a triangle, call DrawTriangle, and so on. So in this case, inside DrawShape, I'm going to have to determine the concrete type that s is based on, that the shape is based on.
Play video starting at :3:47 and follow transcript3:47
So for that, I use what's called a type assertion. So type assertions can be used to disambiguate between the different concrete types that actually satisfy a particular interface. And you can see that here with DrawShape. It needs to actually disambiguate. So if it's a rectangle that's being passed, it needs to call DrawRect. If it's a triangle, it needs to call it DrawTraingle. So you can see us doing that here. At the top, you've got that first type assertion, where it says rect, ok:=, so that will return a rectangle, if the s is actually a rectangle. So if ok is true, and it found a rectangle, it will call DrawRect with that rectangle. Otherwise, the next type assertion actually checks to see if the type of the interface of s is a triangle. So it says, tri, ok:= s.(Triangle) this time. And so, ok will be true if s is actually a triangle. And in that case, tri is going to equal that triangle. And so, you call DrawTriangle with a triangle. So either way, we use this type assertion to disambiguate, to determine the actual underlying concrete type for this Shape2D interface.
Play video starting at :5:4 and follow transcript5:04
Now, another way to do this sort of a common thing that you need to do is what we just did in the last slide, we went down a list of possible types. So rectangle and triangle in this case. But note that an interface can actually be satisfied by many different types. There's an interface that's satisfied by 10 different types, you might need to disambiguate all 10. So to run down the list. If you're this type, then do this. If you're that type, then do that, and so on. And so, there's a switch construct type switch which is just for that purpose. So you got one case for every different type that you need to deal with. So in this case, you got two cases, case Rectangle, case Triangle. And in each case, case Rectangle draws the rectangle, case Triangle draws the triangle. But right before that, you start with the switch. So notice the type Type assertion says s.type. In parentheses you just say type, the generic word type. And so, what happens is sh will be whatever the, it'll be the concrete type that s represents. So if s is actually a rectangle, then sh will be that rectangle, right? If s is a triangle, then sh will be that triangle. And you'll hit the appropriate case. So if sh is a rectangle, then you'll execute the case rectangle. If sh is a triangle, then you'll execute the case triangle. So this is just a more convenient way to sort of run down a list to disambiguate a whole set of types that all satisfy a particular interface.
Play video starting at :6:36 and follow transcript6:36
Thank you.

# M4.2.3 - Error Handling
Module 4, Interfaces for Abstraction, Topic 2.3, Error Handling. So I just want to show a common use of interfaces in Go.
Play video starting at ::10 and follow transcript0:10
The Error Interface. So there are a lot of different Go functions that are built into packages, which return errors. And when I say return errors, what they do is they return whatever they're supposed to return, and then their second return value is an error. An error interface. So and we see it defined over here. The error interface just is any type that satisfies this interface, and error interface just specifies that you have to have a method called, error, which prints the error message essentially which prints something, some text that's useful. So under correct operation, the error return might be nil, so for instance, let's say, I want to open a file. If it opens the file correctly, it'll return nil for the error, and there's no problem. But if the error actually has a value, then you'll probably print the error, and it'll call its error method, which will successfully print the error. So show you an example of that. So basically the idea is, when you, this happens, there a lot of different Go language function like this, which return error as the second argument, okay? And so, when that happens, you should check that error, after the call, and handle it if you need to. So you can see on the top line, we're opening a file. So os.open, open the file by that name, and it returns two things. One is the file F, and the second thing is an error, if an error exist. So then, right after that, for safety's sake, you should check the error. So if error not equal to nil, so if it's equal to nil, you're fine, you go on. If it's not equal to nil, then, do a print that sort of the most obvious thing to do to handle the error, is just to print it. So you println(err) and return.
Play video starting at :1:57 and follow transcript1:57
So printing the error, the format package, the fmt package, which println is a part of. That package will call the error method of the error to generate the string, and print that string. And so, this is sort of the generic way of handling errors in Go. It's a very common way to handle errors in Go.
Play video starting at :2:18 and follow transcript2:18
Thank you.