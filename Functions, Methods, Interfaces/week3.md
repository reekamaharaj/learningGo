# M3.1.1 - Classes and Encapsulation
Module 3, Object-Orientation in Go, Topic 1.1, Classes and Encapsulation.
Play video starting at ::7 and follow transcript0:07
So, classes are part of object-oriented programming paradigm. And this class, this whole course is for intermediate level people, right, so I'm assuming that people already have exposure to programming. And so it is most likely that you already understand what object oriented programming is, although I will sort of redefine it right now, make sure we have a common understanding. And there's always this question, does Golang support object oriented programming? I'll say yes it does. It doesn't have classes exactly, but it has something equivalent, it allows most of the same features. So just to say what a class is though to start, what a traditional class is, that you would've seen in many other languages. A class is basically a collection of data fields and functions that share a well defined responsibility. So it's data fields and functions put together, usually called methods. You call them methods when they're in a class. So data and methods put together. [COUGH] So as an example, say we want a point class, right, that represent some point in 2D space. So, I'll use a geometry program I'm making, okay? So, the data might be the x coordinate and the y coordinate of the point, that's data that you would associate with a point. The functions, there might be a variety of functions, but maybe I've got distance to origin, quadrants, returns the quadrant that the point's in, AddXO set, AddYO set, set X, set Y, there are a lot of functions that I could put in there. But the point is though, that the data and the functions are all related to the same concept, okay? There is a two-dimensional point and these functions are all things that you do to two-dimensional points. And the data is all the data that's associated with two-dimensional points. So, that's what a class is. Now remember, a class is actually a template. So the class contains data fields but not data. What that means is, when you make this Point class, I'm giving a template on how a point should be created. I'm saying, here's the data that a point should have and here's the function that should operate in that data, but I am not actually providing the data. So a Point class is really a template for a point. An actual point has to have data, has to have an x coordinate and a y coordinate associated with it. So an object is an instantiation of the class, an instance of a class. So it contains actual data. So, as an example, say in my geometry program that I'm trying to make, I have a triangle and this triangle has three points on it, three coordinates, (0,0), (6,0), (5,5). So there are three point objects that I want to create, and I call these objects now. These objects, they're made based on the Point class template so they have x coordinate and y coordinate just like the template says, but they have actual values for those. So the (0,0) point will have 0 and 0 for the x and (5,5) point has 5 and 5 and so on. So for one class you can have many, many objects of that class that instantiate that class. They have actual data in them that fill in the data fields. So, just want to make clear the difference between a class and an object. Encapsulation is another concept that's usually associated with object oriented programming. Actually, you know what, I would say it's associated with the use of abstraction in general, but right now, we're talking about it in the context of object oriented programming. And the idea behind encapsulation is that you might want to hide data from the programmer, okay? So when I say the programmer, I mean the programmer who is using your class. So, the person who's defining the class, you can't hide anything from that person. But if there's a programmer who's using your class, you might want to hide some data, conceal something. So you might want to make the data, allow the data only to be accessed using the methods that are part of the class. So rather than allowing the programmer to just go straight in and modify, say it's a point, just go straight in and modify the x and the y values as a point, we might instead say, look, if you want to modify it, you have to use this method to modify it, the method that's provided in the class. And why would you do this? Maybe we don't trust the programmer to keep the data consistent, that's the main thing. Not that we don't trust the programmer, but the programmer has a lot of things on his or mind, might make a mistake, right? So we want to relieve the programmer that burden of dealing with the internal consistency of the data. So we just say look, programmer, if you use these methods to modify the internal data then we, the people who made the class, guarantee that the data will stay consistent, okay? So you, as a programmer, you don't have to think about that, just use our methods. So that's encapsulation. Where you say look, the internal data can't be accessed directly from the outside, or at least part of it can't be accessed directly from the outside. You basically put up a wall, a hard abstraction barrier, which are the methods that you use to access the data. So as an example, let's say I've got a point and a function, and I want to do this point is to double its distance from the origin, right? So I want to double its x and double its y so it's twice as far along the line between the origin and the point, you want to move that point, you want to scale it, to double it, right, double its distance. So you gotta double the x and double the y. So option one is to make a method to encapsulate, right? So you make a method called double distance and it does exactly that function. That's the safe way. Another way is to say look, I don't want to make that method, I'll just let the programmer directly access the x and y, and the programmer can double the x and y when they want to. The problem with that is what if the programmer makes a little mistake, and doubles the X but forgets to double the Y or doubles the X and triples the Y or whatever? Whatever the mistake, if a mistake like that happens then the X and the Y values inside the object are now inconsistent with each other. And so a mistake was allowed to be made, where if you force them to use this Double Dist function that you made and you know you debugged it correctly, then they can't make such a mistake. Thank you.

# M3.1.2 - Support for Classes (1)
Module 3: Object-Orientation in Go. Topic 1.2: Support for Classes.
Play video starting at ::6 and follow transcript0:06
So there's no Class keyword in Go. So Go doesn't officially have anything called classes, although it has something that's just like them but it doesn't have a class. So other object throwing to language or object to language this have this class keyword. And then the data field and the methods that are associated with the class, they are defined inside that the blocks defined by the class, okay? So the code that I'm showing here is not Go. The code is Python, yeah, the Python that I wrote and this is to make a point class in python this is just an example. So in this case, you can say class point and then everything in that block is associated with the Point class. Now, I'm defining a function called init which is its constructor. And you'll notice inside there, it defines self.x=, self.y=. So self.x, self.y, those are the data that are associated with the point, and we're assigning them a initialization function. So it's assigning to values x and y values. But this is normally how it's done in other object oriented languages. Go does not do it in the same way, it doesn't have a class keyword like this, but you can get a similar effect. Okay, so in Go, they have a different way of associating methods with data. So remember, that's what a class really is, a class is a bunch of data associated with a bunch of methods that operate on the data. And together, the methods and data make what you would consider to be a class. So you need to have a way to associate a method [COUGH] with some data. And the way that's done inside Go is using a receiver type, so when you define the function you give it whatâ€™s called a receiver type which is the type that method is associated with. So the data is going to be some type. And the method, the way you associate the method with that data is when you define that function you give it a receiver type. And that receiver type is the type that that method is associated with. And then when you want to call a method you use standard dot notation to call it. So let's show an example. So let's say I make up a new type called MyInt, and it's just an int. Okay, so type MyInt int. But it's MyInt, so I can make up methods for this type. By the way, I can't add associated methods with existing types. As a rule, whenever you associate a method with a type like this, using a receiver ,type associated with a receiver type. You gotta make sure that the type is defined in the same package as the method that you're associating with it, they have to be in the same package. And so you can't do that with a built in type like int or string o something like that, you can't just add methods onto that because they're not, they're built in they're not defined in the same package as your code. So I make my int, now, I make a function, this function, double. And I want to associate double with the MyInt type. So Double is going to be something that's going to double an integer and only works on MyInt. So when I define the function, notice it's slightly different than a normal function definition. Before the name of the function Double, to the left of that, highlighted in red, I have the receiver type defined. So MyInt is the receiver type and mi is the variable that refers to the particular receiver object that this Double is going to be called on, okay? Because remember when I call Double, when I invoke double, I'm going to have to say, say I have, actually let's look at the invocation down here. Actually, if you look at the bottom, func main, I declare a MyInt v, v := MyInt(3). So I make it, and that's what v is. Then when I call, you see highlighted in red, when I called double, I say v.Double. And so what happens is, when it's trying to figure out this double, it looks back at the things to the left of the dot. The object to the left of the dot looks at what type it is and it knows, that's the Double that I want, the Double that's associated with that type. So that's what the dot notation is for, basically the object to the left of the dot tells you what type you're looking for, because double could be defined in lots of different types. But I'm specifically looking for Double for v's type which is a MyInt. So anyway, back to the definition of the Double function from MyInt, the double method. I have to associate it with the MyInt type by putting the (mi MyInt) in parenthesis, the highlighted red part, before the name of the function, when I defined the function, when I declared the function. So and then what happens is inside the definition, so if we look inside double it just returns int (mi*2). Now, notice that it takes mi, now it refers to mi, because basically what's happening is that mi that object to the left of the dot when you make the call. That object ends up being an argument and implicit argument to double. We'll talk about that in a second. So this function just takes mi whatever integer it is and multiplies it times 2 turns it into an integer and returns it as an integer. All right, so then in the main I can just call v.Double and it call the Double that is associated with the type of v which is MyInt. So, what I'm showing here is just that this type MyInt is the receiver type for this function Double, that I have defined. So whenever I call Double, I have to prefix it using this dot notation, I prefix it with an object of that type, of the MyInt type, so v.Double(). So that the machine knows, okay, this is the Double that I want, the one that's associated where this MyInt is the receiver type. Implicit Method Argument. So what I'm saying here, is that even though it looks like Double takes no arguments, right? If I look at the definition of Double, there's no arguments there. But there is an implicit argument. Whenever you have a receiver type, whenever there's a method, it has a receiver type. The object of that receiver type, that it is to the left of the dot. That is an implicit argument to the function, to the method rather. So even though double looks like it has no argument, it really has one argument. Okay, a hidden argument. You do not pass it explicitly. So when I call Double I say (v.Double()) in parentheses I have nothing, right? But that v is going to be passed to the Double function when you actually make the call. So that's passed automatically invisibly, the programmer doesn't have to see it. But it's important that you as a programmer are aware that it is actually being passed. Reason why is because it's passed call by value. So this is how passing, argument passing is done and go is call by value. So what happens is when that v, that object to the left of that dot gets passed to Double implicitly, it is passed by value, a copy of v is made and passed to Double. So this impacts what Double can do. So it's important to realize, if v is actually being passed, the object to the left of the dot is being passed as an argument even if though it doesn't look like it in an obvious way. Thank you.

# M3.1.3 - Support for Classes (2)
Module 3: Object-Orientation in Go, Topic 1.3: Support for Classes.
Play video starting at ::7 and follow transcript0:07
Now, in a normal object directed language, it's a class is defined, it's data associated with some kind of methods. And usually, you can associate lots of different data, you can roll up lots of different variables. Maybe an anti-float, whatever type of data you can put a lot of it, as much as you want together. And then associate that with any number of methods, asnd you can do the same thing in go. Of course, you're going to use a receiver type, just like we talked about, you don't have classes, you have receiver types. But you can just use a type that has lots of data in it. So, before we're using examples where the type was just an int myant, right. It was just an int, one piece of data. But it's very common to use a struct as a receiver type, a struct of some kind. So structs basically allow you to compose all kinds of different data fields. So in this case, my point struct, I'm just composing two numbers, an x and a y, both floats. So two floating point numbers, they're composed into one struct. But remember, with a struct you can compose an arbitrary amount of information, you can put together. So it's very common to see a receiver type be a struct of some kind with lots of different data. It's a traditional feature of classes, people just roll lots of different data together.
Play video starting at :1:27 and follow transcript1:27
Now, the structs with methods, you could take a struct and define it as a type, like we just did with that point type. And then you can associate methods with that type. And then you get what you would normally think of as a class in another language. You get the struct with lots of different data, associate it with as many different methods as you want to associate it with struct. So, we got an example of that right here, we're using the point that I defined just in the last slide. So, this point, I want to make a function called DistToOrigin, and I've defined it right there. Notice that to the left of the name of the function DistToOrigin, I pass it a point, p Point, right? When I say I pass it, it's an implicit pass, right. So it doesn't have any explicit arguments, but its receiver type is a Point called p, and that will be implicitly passed to DistToOrig. And then if you look at the function, the insides of it, the internals, it's just doing the Pythagorean theorem, right. It's squaring the x, squaring the y, adding together, then it returns the square root. So it just does Pythagorean theorem nothing sophisticated. Then in my main, I can make a point p1 is three comma four and then I can just call p1.DistToOrigin. And that p1 together with its x and y coordinates will be implicitly passed to dist to origin. Dist to origin will then do Pythagorean theorem and return the distance which is five in this case, thanks.

# M3.2.1 - Encapsulation
Module 3 or Object Orientation in Go. Topic 2.1, Encapsulation. So Go provides a lot of different support for encapsulation and keeping private data. But you want to be able to have controlled access of the data. So typically, even if you have private data in some package, you probably don't want to hide it completely. All right, or else why are you even importing it anyway? You hide it but you want to have controlled access to it. So what that means is you want people to be able to use that data but only in the way that you define, okay? Using your methods or functions. So what you can do is you can define a set of functions, public functions, that allow another package, an external package, to access the hidden data. So as an example, say I got my data package right there, package data, got my hidden variable x int= 1. And then I can define inside that same package a function called PrintX. And PrintX just prints x, okay? It does exactly what it says. Now PrintX, notice it starts with a capital letter, so that means it gets exported. So if my main package decides to import the data package, the main package will be able to access this PrintX method even though it can't directly access the x. Okay, and so now what happens is I can access the main method, the main function can access the x variable only through this PrintX function. So if I want to see the x value, I have to call PrintX. So if I look in my main code, I import the data and then in my main I can call data.PrintX and then I can see the value of x. Even though I couldn't directly access x from my main, I can indirectly access it through these public functions. So this is generally how we're going to control access to data that we want to hide. You want to give access but only in a controlled fashion. We let them see what we want them to see, is the idea. Also, to modify code, to modify x, right. I mean as it is, x cannot be modified externally. There's no way the main can directly see x or modify it. But if I wanted to allow the main to be able to modify x, I could make some kind of a function inside the package, start it with a capital letter that main could call to access the variable.
Play video starting at :2:21 and follow transcript2:21
So we can do this with structures too. So say we have some kind of type that's a structure. Like a point type. We put that in our data package again, right? And maybe the x and the y and coordinates, we don't want the outside user, the person who is using this type to be able to directly modify x and y. We want to be able to control their observation and their modifications to x and y. So we give them lower-case names, lower-case x, lower-case y. But we define a set of functions inside that package, the data package, that are public, and allow another package to use to actually access x and y in some way. So for instance, first one you might want to define is InitMe that I'm defining down here. And that, notice it is associated with the point type, the receiver type is Point, so p *Point. I call InitMe and InitMe just allows me to initialize x and y, right? That's something clearly you're going to want to do. You make a point, you want to initialize the x and y values. So I do it through this InitMe method that I'm defining. And it just sets p.x equal to the first argument, p.y equal to the second argument. So in this way, using this function, this InitMe function, I can modify x and y, even though I can't directly touch x and y I can do it through this function. Then a few more functions that you might want to add to allow access to the x and y, they're hidden. This is Scale. So Scale, again, it's associated with Point, its receiver type is Point. And Scale, you pass it a floating point number v, and it just scales x and y together, so it multiplies p.x times the scale factor, p.y times scale factor. Again, we're not trusting the programmer to do this, we're scaling both of them together. So if they want to scale, they have to call our scale function and they can scale them both. Also, print me, maybe I want to be able to print the x and y values. And since another package can't directly access x and y to call Println on it, we have to provide a function for that, PrintMe. And it just goes in there and it prints out the x and y, prints out p.x, p.y. So now we define a set of functions, a set of methods, really, because they're all associated with the type Point. And these methods are all public because we started them with capital letters, Print and Scale, they're all capital. So we can access them outside in, say, our main package.
Play video starting at :4:48 and follow transcript4:48
So in our main package we can use them, so for instance, in
Play video starting at :4:53 and follow transcript4:53
this main we make a point, data.Point call p. Then we call p.InitMe, it initializes x and y to 3 and 4. Then we call p.Scale to scale it, to multiply 3 and 4 times 2, so it should be 6 and 8. Then we call p.PrintMe, it prints 6 and 8. So if we ran this it would work. And in this way even though we can't from the main, we can't directly access x and y, we can't say p.x= bam p.y=, right? But we can access them through these methods that are provided to us in a controlled way. Thank you.

# M3.2.2 - Point Receivers
Module 3, Object-Orientation in Go, Topic 2.2, Point Receivers. So we've been talking about methods, defining methods for an association with different receiver types. So there are a few limitations to this process that we may need to overcome. So remember [COUGH] that this receiver type is implicitly passed. The receiver object is implicitly passed as an argument to the method. So even though it's not explicitly passed, it is implicitly passed. And remember that argument passing in Go is passed by value, called by value. So that means that the method can't modify the data inside the receiver object. So as an example, let's say we had some mythical OffsetX, and it should increase the x coordinate of a point, right? We wanted to add some constant to the x coordinate at some point. So in our function main, we say pl := Point (3, 4), we make a point. Now we say pl.OffsetX, and we pass it 5 is the value that we want to add to the X. That won't change the X. It can't change the X coordinate. The reason why is because this OffsetX is being passed a copy of p1, not appointed a p1, a copy of p1. And so as it gets a copy of p1, it can change it's copy, so it gets its own p1.x copy, it can change that from 3 to 8. But that goes away as soon as soon as the function is done executing. So as Offset as x is done executing, that goes away, because it's in its environment is gone. So what we want in this case is to be able to change the actual values inside p1, but you can't, because they get the p1. The p1, the object is actually passed by value. Another problem with that is if the receiver is large, a lot of copying happens when you make a call. So when you call by value and the receiver object is passed as an argument, the whole thing has to get copied onto the stack internally. And if it's a large receiver object, then there's a lot of copying. So in this case, I've got my type Image [COUGH] and this type is a 100 by 100 array events, which is actually small for an image, okay? So that's 10,000 int. So when I call this BlurImage [COUGH] which is some method that's associated with whose receiver type is this image. When I call BlurImage, the i1, this image, actually has to get passed to the BlurImage method. And that's 10,000 ints that you've got to copy out of the stack and that can take a long time. And images actually are a sort of worse case, because they can get gigantic, right? 100 by 100 is not even big, so that can waste a lot of time.
Play video starting at :2:49 and follow transcript2:49
So this is the problem.
Play video starting at :2:51 and follow transcript2:51
So what do you do? Well, we do what we did before with method argument, not even with method, with regular functions. We can just pass, instead of passing, calling by value, you can call by reference. So you explicitly pass the appointed to the object, rather than the object itself. So the way you manage this is when you declare the function. Like we're seeing here, we're declaring this OffsetX. See this receiver type to the left of the name of the function. So in parentheses is p *Point. I say *Point this time, *Point, right? Instead if I said p *Point, then I'm passing the point called by value. But if I say p *Point, then now p is a pointer to a point, right? So now, and when I implicitly pass this p value to offset x, it's going to pass a pointer to the point type that we're talking about. So now inside the function, I say p.x = p.x + v and that'll actually work, because p.x is now, since p is actually a pointer to this structure. p.x points to the actual x value in memory. So you can actually modify it now, because you didn't call it by reference.
Play video starting at :4:7 and follow transcript4:07
Thank you.

# M3.2.3 - Point Receivers, Referencing, Dereferencing
Module 3, object-orientation in go. Topic 2.3, point receivers, referencing, and dereferencing.
Play video starting at ::7 and follow transcript0:07
So one thing about using a pointer receiver is that there's no need to dereference the pointer inside the method. So what I mean by this is that, so let's take a look at this example OffsetX. I want it to have a pointer receiver, because I want OffsetX to actually be able to modify the X coordinate of the type. So I have to pass it a pointer to p. So now if you look to the left of the function name OffsetX, you see p star point. So the receiver is a pointer type. Now notice inside the function I say p.x=p.x+v.
Play video starting at ::43 and follow transcript0:43
I don't say *p.x=*p.x+v, right. That's a dereferencing that you would normally use with pointers. I don't have to do that because this is a common enough thing that going just allows you to get it with basically the ( ) recognizes it and says okay, I know what you mean. If you can just say p.x and it knows even though it's a pointer, it knows to get the x p, it knows to basically de-reference it automatically. So, it's just a handy shorthand, you don't have to do the dereferencing when you're doing this.
Play video starting at :1:16 and follow transcript1:16
And likewise there's no need to reference either. So, say I'm in my main and I want to I've defined my offset X, as I showed you, where it accepts a pointer,
Play video starting at :1:29 and follow transcript1:29
the receiver type is a pointer, right? Now in this case, in this main, I'm declaring this point p I'm making it 3,4. So p is actually a struct, right? It is the type, it is the actual struct. It is not appointed to the struct, it is the struct. But then when I call OffsetX, I say p.OffsetX, when really, since offset X is supposed to have a point to receiver you would think you would have to say anforsand P dot offset X. But you don't, you can just say P dot offset X and the goal compiler recognizes that just because this is a common thing to do. So it just makes it easier, it's a convenience. So when using pointer receivers it is good programming practice to either have all methods use pointer receivers, or have none of them use pointer receivers. It's just a good standard. It's easy to get confused. So if you have some methods, use pointer receivers and some not use pointer receivers It can get confusing. You'll send a pointer to the one that doesn't need a pointer and so on. So it's just more appropriate to use, it's good practice, you don't have to. You can mix and match if you want, but it's good practice to use all pointer references for a particular type or all non pointer references.
Play video starting at :2:47 and follow transcript2:47
Thank you.