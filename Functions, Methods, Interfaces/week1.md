# NOTE
There is a small amount of controversy surrounding the expressions "pass by pointer" and "pass by reference." Just search the web for "Pass by Pointer vs. Pass by Reference in Go Programming" and you'll see for yourself! Be aware that our instructor uses "pass by reference" where some Go users would say "pass by pointer" or "pass a pointer."

# M1.1.1 - Why Use Functions?
- Function: Set of instructions with a name, name is optional
- main function in Go, where the execution starts
- function contents are between {}
- Calling a function is to execute the function
- () after function name will have the parameters
- func nameOfFunc(argument string) returnValue string{functioDoesSomething}

- Why use a function
    - Reusability: don't have to rewrite the same code
    - Saves time for coder
    - Shrinks size of code
    - Can use the function across projects
    - Others could import code as a library and use the code
    - Abstraction: hiding details that are less important
        - Helps simplify things
        - Group things
        - Hide details
        - Only need to understand the input-output behavior
    - Improve understandability of code
    - Organization
        - Functions organized in a hierarchy
    - Ability to glance at code and understand how it works
- Naming a function well helps with understandability

# M1.1.2 - Function Parameters and Return Values
- Parameters: function inputs - function definition
- Argument: Data applied as parameters - function call
- A function doesn't need parameters/arguments
- A function can accept multiple parameters
- Parameter can come from different places
- Don't have to give a parameter a type
- Comma separate multiple arguments of the same type

- Return values: function output - function definition
- A function can have multiple outputs
- Return values have to have a type
- Return value from function can be assigned to a variable

# M1.1.3 - Call by Value, Reference
- Call by value: how arguments are passed to parameters
    - Arguments are passed as parameters
    - The data used in a function is a copy of the original, not the original value
- Important: function being called can't interfere with the original variable
    - Modifying a parameter in a function doesn't have an effect outside of the function
- Advantage: Data encapsulation: functions can not alter the variable
    - Limits the propagation of erros
    - Localizes errors
- Disadvantage: Copying time
    - Time to copy the argument into the parameters

- Call by reference
    - Not built into Go
    - Manually do it by passing a pointer instead of an argument
        - Pointer is a reference
    - *y *int, pointer to y
    - &x when calling the function, passes the pointer to x, not a copy of x.
    - A modification to the pointer, is changing the value at the location of storage,
    - Not passing the integer or data to the function, the pointer/reference to the data is being passed. Allowing the ability to alter the variable
- Advantage: copying time, could copy only a portion of an argument instead of having to copy the whole argument by copying the pointer
- Disadvantage: Data encapsulation, a bug inside a function could alter variables outside of the function and create bugs, errors


- pass by reference, if you definitely want the function to modify the variables in the calling function

# M1.1.4 - Passing Arrays and Slices

So say you want to pass an array as an argument to a function. Maybe you want to do some processing on the array or something like that inside a function. So the arguments are all copied, because this is called by value, so the whole array has to be copied to the parameters. And if the array is big, then it's a problem, it'll take a lot of time to copy, also use an excessive amount of space. So as an example of that, we've got this function, foo, and it takes as an argument an array of three integers. Three is small, but this is just an example. You could imagine that could be 300,000, right? So it takes in an array of three integers, and so that's declared there, (x [3] int) and it returns an integer. And just returns the first element of the array, x [0]. So the function main, that first defines an array, a: = [3]int(1, 2, 3). And then it prints out whatever foo it returns. So it calls foo with that array, a, which returns the first element, which would be a 1, then it prints that out. So in this case it has to copy that whole array over, when it makes a function call, it copies that into x, the parameter of foo. And that wastes time if it's a long array. So what do you do? So one thing you can do about that is you can employ, basically call by reference, right? So you can, instead of passing the array to foo. You can change food so that it takes a pointer to an array. So that's what we've done here. Function foo, if you look at its argument, it's parameter list, it says foo(x*[3]int). So as a pointer to a three element array of integers. And then inside the function foo all it does is, it takes *x which is pointed to the array, so *x is x of the array, right? And it looks at the zeroth element and adds one to it. So it increments, it should increment to zeroth element. Then if I look at the main, it defines the array, a. Then when it calls foo, it doesn't pass at a, it passes at ampersand a, it passes on the point into a, and then it just prints out a. And what should happen is since foo got the pointer to a it can actually modify that array, a. And it should modify it by incrementing the first value. So if the array starts out as 1, 2, 3, it should increment that 1 so it's 2, 2, 3, and then prints out, prints the array when prints it, it prints 2, 2, 3. So you could this, you could deference use referencing and dereferencing operations to pass array pointers and use array pointers. But that's messy and it is not necessary in GO lang. This isn't the way, the neat way to do it in GO. So the way you do it in GO, is you use slices instead. In fact, in general in GO get used to using slices instead of arrays, just in general. So a slice is like window on an array, right? But remember that when you declare a slice, if you declare a slice from scratch or however you make it, it'll make the backing array behind it, right? So you can almost always use a slice instead of an array. So passing a slice copies the pointer. So we pass an array, it copies the whole array. But a slice is not actually an array. It's really a structure that contains three things. A pointer to the array or a pointer to the start to the slice in the array, and the length, and the capacity, okay? So it is really a structure with those three pieces of data, one of which is a pointer, okay? So so still rhe GO lang is still call by value, but when you pass a slice, since the slice contains pointer your copying the pointer. So the called function, when you pass a slice you actually gets the pointer and also the length and the capacity. So it can use that pointer directly to modify the slice without you having to explicitly dereference and reference like we did with the array example. So here's an example like that. Here with this foo function, this time it takes a slice, I'm calling sli. And notice that when you declare the slice, you don't have to specify the size. In fact you can't specify the size. You just give the square brackets. So it says sli [ int ], there's no number inside the square brackets, because that means it's a slice. So you do that and it knows, okay, this function foo takes a slice as its parameter. And then what it does, it takes a slice and just adds one to slice element 0. Then if we look at the main, this time what we do is, when we declare, we don't declare an array, we declare a slice. And it's only slightly different. So this time when we declare a, make that array, or rather not a, and not array, it is a slice now. A := []int(1, 2, 3), the only difference is I didn't specify a size, right? Inside the square brackets I didn't put a 3 like I did when I declared an array. This time I just put square brackets so now it recognizes that a is actually a slice. So then I can just call foo past the slice of a, which now slice and it works exactly the same as the last program. And so when you print a, it will have incremented the first element, which was 1 and now is 2, so it'll print that 2, 2, 3. So in general, in GO, try to use slices instead of arrays, okay? And specifically when you want to pass an argument, an array argument, don't pass an array argument, pass a slice argument. Because then you don't have to do all the copying that would be associated with an array. Thank you.

# M1.2.1 - Well-Written Functions
Module 1, Functions and Organization. Topic 2.1, Well-written Functions.
Play video starting at ::6 and follow transcript0:06
So we're going to talk a little bit about how you should write functions. Now, this isn't actually necessarily specific to Go. But this is more good way to construct your code so that your code is well-organized and easy to understand, okay? And understandability, I'm highlighting this idea of understandability. It is important to be able to understand your own code for many, many reasons, okay? Mostly for debugging but also maintenance, other people interacting with your code, it needs to be understandable. And the way you write your functions, the way you define your functions really impacts understandability. So if we look at a block of code, we could roughly say that a block of code is a bunch of functions and a bunch of data. So a bunch of functions that are the operations that you can perform and the data that you're going to perform the operations on, okay? So you can see really any block of code, any program as a pile of functions and a pile of data somehow organized together. So when I say understandability, when I say, this program is understandable, here's what I mean. I mean that If you're asked to find a feature, you can find it quickly. So as an example, where's the function that blurs the image? Let's say your writing some graphics program, where is the function that blurs the image? You can locate that. Now, you might be asking that yourself, right? Because you found a bug, something is not working, you need to find that piece of code. Or that could be some kind of code review meeting or you're dealing with other people you're working with. And they need to understand how your code works and they ask you this type of question. Maybe it's your boss, right? Your boss is like, look, where's the code that does this? And you will look like an idiot if you can't answer that. It's your code, you wrote it, you should know it, right? So you need to understand the organization of your own code. Now, a lot of this is memorization, but it's also a matter of organization. If you organize it well, it is much easier to find things. So where's the function that does this operation, blurring your image? Or where do you compute the average score, whatever the question is where is the code that does this? Where is the code that does that? You need to be able to find that, okay? And that's an understandable piece of code if you could find that pretty easily and even better if somebody else can find it. So if you write the code and you give it to somebody else because you're probably working on a team, right? And that other person can find where the image is blurred or where the average scores computed. If they can find it quickly, that's a real measure of understanablity, right? And remember this too, I know a lot of students in my classes, they underrate how important this is, right? They think, look, it's my code, of course, I know how to understand my code, right? So believe me, if you write a complicated piece of code and you walk away from that code for a month. You come back, you will lose track of what the heck that code did, you will not understand your own code, okay? So you really want to construct in such a way that it is easy to figure out where these features are located inside your code. Now, another aspect of understandability is finding where data is used, because often you'll get some kind of problem where this data is incorrect, okay? Or this data is not just used. Actually, I said, where data is used, also where data is used and where it's defined, right? So this data is incorrect, how did it get incorrect? What part of your code actually affected that data? That type of question you want to be able to ask. So you want to be able to trace through data. You'll say this data, where is it used? Where is it defined? So where do you modify the record list, right? So you got some record list, you realize that record list, the contents of that list are wrong, right, while you're debugging. Where did you modify that? You've gotta find that so you can find where the bug is, right? Where did you access the file? Maybe the file has the wrong data and you want to know what code that's affecting, right? So where did you access that file? Where did you access these different pieces of data? So this is what I mean by understandability, you need to be able to find a feature, find the code dedicated to a particular feature, find it quickly. Also data that could be wrong, where is that data used and where is it written to? So where is it used and where is it modified, you need to be able to find it quickly. And an organization, writing a code, writing a function and organize where it really helps you with that. So very basic debugging principles and there are a million debugging principles but I'm going to just be really basic now. So say you run your code, the code crashes. And it crashes inside some functions somewhere, right? So some function you wrote, it crashes on line 100, right, some function. So I can broadly say that there are only two ways that this could go wrong, two options for any kind of bug, okay? It could be that the function that failed is written incorrectly, okay? It just did the wrong thing, okay? So maybe as an example, it's supposed to sort a slice, and it sorts it in the wrong order. Okay, it did the wrong thing, right? So the function could do the wrong thing or maybe the function is written perfectly well but the data that the function uses is incorrect. So maybe this function is, it sorts the slice just fine but the slice has wrong data in it, right? So somehow the data that it got is wrong so when it does a sort, of course, this result is going to be wrong, right? Because the original data was wrong. So the function that you're working on, it could be messed up or its inputs could be messed up. Now, its inputs, remember, can come from the parameters, right? So they could be, or even sit past to it. But these inputs don't have to come from there. They could come from maybe a file or some user input or something like that. So you gotta think of all these inputs. So this is just my sort of high level debugging principle. And notice how I'm dividing this, I'm saying look, either function is written incorrectly, or it's the data is at fault. So it's the function written wrong or the data is at fault. Now, of course, when you trace that back, you'll see the data is probably incorrect because some function wrote it incorrectly. But locally, you can say, look, either this function is wrong or the data that it's working on is wrong.
Play video starting at :5:52 and follow transcript5:52
So, in order to support debugging, when you run into a bug like this, first thing you've gotta be able to do is understand your own function, okay? So functions need to be understandable. So when you look at that function, look at the code, you gotta be able to look through it and manually say look, is this right? Is it doing what I think it's doing? It's actual behavior, does it match what I want, desired behavior? So your function needs to be written in understandable way so you can determine that without too much difficulty. The next thing though is the data needs to be traceable. So what that means is, is maybe your function is perfectly fine, but there's some input data that it got past that somehow it access that was wrong, okay? So you need to be able to figure out where that data come from, so you can follow back to where the original fault actually happens, right? Now, this could be easy, it could be hard. Global variables for one complicate this. Because one thing about having no global variables is that the inputs to the function come straight from the parameters. So you know where every piece of data came from, it came from the caller, right? But if you use global variables, then they can come from whoever wrote to the global variable. And since these variables are global, anybody could have written to it. So it's much harder to trace back which function is at fault for writing the wrong data to a variable. That's exactly why global variables you should be careful about. And I'm not going to say never use them. People use them, and there are reasons, I use them sometimes, but just understand that they add this complication. They make it hard to debug just because you know this data is incorrect, you don't know what the source of that was. And then you've gotta do something more complicated to figure that out. Thank you.

# M1.2.2 - Guidelines for Functions
0:00
Module One; Functions and Organization. Topic 2.2; Guidelines for Functions. So, I'm going to give a few tips on making good functions, okay? Functions that are understandable. To facilitate debugging and other people understanding your code, working together with people, and so forth. Modification later, maybe you want to update your code you need to understand what you wrote. So to facilitate that there are a few tips. Function naming, really important. Give functions a good name for goodness sake some kind of a name that describes the behavior of the function. So, what you want your goal in the naming, if at all possible is that the behavior can be understood at a glance. So, you just look at the name and you know what this thing does. Now, parameter naming counts too. So, you also want parameters that are well named too, so you understand what they mean. So as an example, I'm showing two functions just the first line of the declaration, right? The first function is called process array, it takes a which is an integer slice and it returns the float and that's all I know about it right now, right? Now, if instead let's look at the bottom one which actually these two functions, these can do exactly the same thing, okay? But they're defined differently, they're declared a little bit differently. So the second one, is called ComputeRMS. It takes in a slice called samples of floats and it returns a float. So, notice that these two are compatible, these two are probably doing exactly the same, say they do exactly the same thing. That first line is declared the same way but their names are different. So, ProcessorArray versus ComputeRMS. Now, RMS remember these names are always domain dependent, okay? RMS stands for root mean square, if you look in a time varying signal it is something like an average, okay. Now, I don't want to go into what RMS is but if you know this type of stuff you're in, if you're working in this domain you would know what RMS is. So ComputeRMS has a distinct meaning to anybody working in this domain. So you look at that and you know instantly what that is. ProcessArray can mean anything, right? Process how? Right? Who knows? Now then, also look at the name of the argument. For ProcessArray the argument it's called a, that is completely generic. Who knows what that is? Where ComputeRMS, I call it samples? Because guess what? It's a bunch of samples of a time-varying signal, right? So, the naming gives you some an idea of what type of data is being parsed and I can look at it and understand what it's doing without knowing anything about the actual code inside the function, about how it's implemented. I can just look at the name and say, "Ah that's what it is". So that's what you want. Now, notice that these names, they're going to be domain dependent, right? So ComputeRMS, you have to know what RMS is but that's a shorthand that anybody who does this type of work, who works on time-varying signals, they're going to know what an RMS is. So that's a good name. Now, another thing about names that I skipped here is that you don't want to be too long. Okay? People can go overboard, they can make them so descriptive there, just burdensome, okay? You don't want it to be too long and how long is too long? I don't know. ProcessArray is getting there as long as I wanted to be, maybe a little longer than that. There's no hard limit on that but you don't want to put too many words together, right? It gets ridiculous. So, naming is really important and in my classes I teach Python, here at UCI and I tell students this and they don't listen. They still name these variables X and I'm like what the heck? And they are like, "Professor Harris, what's wrong with the code?" I have no idea, I don't know what X and Y and Z are. How am I supposed to know? And nobody can know that and sure maybe you don't care what the professor thinks but you will one day work with a group of people and your boss will be like, "Okay, what is this?" All right and he/she will get upset. You know what I'm saying? If you want to work with people, naming is really important. And you yourself when you look at the code later like a month later, it will be much easier for you to understand your own code if you have good naming. All right, another thing that you want in function definitions is you would like to have functional cohesion. So what that means is that the function should perform, only one "operation" and note I put operation in quotes because what is an operation? I don't mean one instruction; plus, minus something like that. An operation the size of it, the complexity of it, really depends on the context on what the application is that you're making. So, giving an example, say you've got some geometry application. I don't know it's doing things with points in three dimensions. Maybe you got some functions like point dist for point distance, the distance between two points. Common thing you might do. Draw a circle, triangle area, these names are all things that are in the domain geometry and these names are all good names meaning you can look at the name and figure out what it does and not too long. Okay? So, just from the name you can look, you don't have to look inside the code, you can just look at the name. Now, what I mean by functional cohesion is you would like it if each function did basically one thing. So, point dist it computes one thing, the distance between two points. Draw circle, it draws a circle, it does one thing that makes sense in the domain of geometry applications in this case. Now, let's say though that you're making this geometry application and there's some case, some instance where under some conditions you need to draw a circle and then you need to compute the area of a triangle. You might have to do that, do the one thing and then the next. So, it would be a bad idea to put both those operations into the same function. You might say, "Well, I'm going to need to do both, I'll just put them into the same function and it can draw a circle and it can compute a triangle's area." One function that can do either or let's say. That would be a bad mistake because now you've got a function that does two things and the reason why that's a bad mistake is because it doesn't make sense to the human. Meaning how would you name such a function? Draw a circle compute triangle area, it's much cleaner in your mind if the operations that the function performs are separate. So drawing a circle and computing a triangle area, they are two separate functions to most people who think about geometry. They're two separate things, so you'd want to keep them as separate functions. If you start putting them together then it just doesn't make sense to the human and you want it to make sense. You basically when you write this code you want to be idiot proof, okay? You got to expect that a bunch of idiots are working with you and they're going to be looking at your code and they don't understand a thing. So you got to make this code so easy and obvious for them that they can't help but understand what you're doing, okay? That's what I'm going for here, right? You want it to be obvious and putting together different functions, different operations into the same function is a confusing thing. So you want to separate these operations into different functions if you can. So another thing to do with functions to make them simpler, is to reduce the number of parameters, okay? Limit the number of parameters that you take. So more parameters just means more complication because if you're trying to understand what a function does say, it goes wrong. Say it takes 20 parameters, you got to look at all 20 of these parameters, right? And which one could it be? It's much easier if you have fewer parameters that you can keep track of so because debugging generally requires tracing the data and which of the parameters. So if you have to trace that back, you don't want to have to trace back 20 different pieces of data, you'd like to trace back five or something like that or look through five pieces of data rather than 20. So, the fewer the better. So, debugging is just generally harder when you have more parameters. Now you got to think of why it happens like, say you do make a function that does have a lot of parameters? Why did that happen? It may be that the functions you wrote had bad functional cohesion. So, let us say for instance, you made the mistake I talked about before, you want a function that can draw a circle or it can also compute a triangle's area. These two operations require entirely different arguments, drawing a circle requires information about the circle, its center, it's radius basically. Drawing a computer triangle's area requires information about the triangle, maybe its points, its coordinates, or something like that. So, if you make a function that does both of these operations it's got to take all the arguments for both different things. And so you would tend to get more arguments, more parameters, so you want to reduce the number of parameters, you may want to look at the code and say, "Oh, wait a minute I'm putting these two operations together, I can separate them and reduce the number parameters required to parse to each individual function." Okay, so, another way to reduce the number of parameters. Say you can't split it the way I just said, say this function does have good cohesion, okay? So that's not a thing you can do is just split it. One thing you might look into is grouping related arguments into structures. So, as an example, say you got a triangle area function. A bad solution for this, when I say bad solution, a solution for parsing its parameters. You could say its parameters are three points, okay? Because you need three points to define a triangle, right? So you got to give it three points and each point let's say is in three-dimension space, we're working in. So each point is going to have three floats associated with it, right? XYZ. So in total, I can say this triangle area could take nine different arguments, right? XYZ for the first point, XYZ for the next, XYZ for the next. It is a lot of arguments, right? A better solution, good solution I'll say better solution let's say, not the best but better solution is instead, I define a new structure called point, right? And this structure called point, it has X and Y and Z. It has three floats XYZ. Then, once I define that instead of passing to my triangle area, nine different values for X and Y and Z, XYZ, XYZ, I can parse it three things, three points. That each point inside it has three floats but when I'm looking at my declaration for triangle area, I only see three things point one, point two, point three and it makes more sense, it's easier to understand in my mind. Now, an even better solution that I didn't put up here is I can say triangle area takes one argument which is a triangle. So I can make another structure which is a triangle type rather, and this triangle, it could have three points associated with it and each point has three floats. So I could make a triangle area that just takes one argument which is a triangle structure, right? That's even better, so anyway this type of thing by grouping related piece of data into structures. You can reduce the amount of arguments you get to parse your function. Now, remember don't force this meaning, only group pieces of data if they are actually related, right? You don't want to group completely random pieces of data into one structure because then you get a structure that makes no logical sense. You don't want that but often you can find the ones that are related and put them together. Thank you.

# M1.2.3 - Function Guidelines+
Module 1 : Functions and Organization. Topic 2.3 : Function Guidelines. So another thing that you want to do with functions is you want them to be not too complicated. You want them to be understandable, they shouldn't be too complex. Now this term complexity, when you measure the complexity of a function, this is definitely arguable. People have different opinions on what comprises complexity, what makes up the complexity of a function. So we'll start out off with function length, because that's sort of the most obvious. Everybody uses that as a very rough approximation of function complexity. So functions need to be simple, and one way to make them simple is make them short, okay. Now this doesn't always work, because short functions can be complicated. I have definitely seen that, especially in a C or something, you can put everything into one line, right. Yeah, I'm not counting lines that are, you could technically write a whole go program in one line, right? Assuming you use regular line separations, that's what I'm talking about when I'm talking about function length. And you could rely on number of lines, line count.
Play video starting at :1:3 and follow transcript1:03
In fact, I remember one professor here, he basically insists for NC that all his students write their code, every function, is no longer than 10 lines. I think that's too strict, sometimes you gotta go over that. But I see where he's going with the idea, right? It forces you to have some measure of simplicity in each individual function.
Play video starting at :1:26 and follow transcript1:26
So the question then is, so how do you write a complicated piece of code with these really simple functions, right? I mean, some code you write it has to be complicated. And there's no real avoiding it, right? So what you can do is, when you define your functions, you can make sure that each individual function isn't too complex. You can make attempts to limit the complexity of an individual function. And what's going to happen is, in your code in general, there's always what I'm calling here a function call hierarchy. Meaning you've got a function, and it calls some other functions, which call some other functions and so on. I'll call that a hierarchy, right? This calls that, which calls that and so on. So you can use that hierarchy to simplify the complexity of each individual function. So, as an example, I've got Option 1. Option 1 you write everything in 1 function, 1 big fat function 100 lines long. Or I can go to Option 2. Now, Option 2, now I have 3 functions. Instead of 1, I've divided it into 3. The first function, in this case, is really short, right, with just a few lines, but it calls the other 2. And then, the other 2 functions are each 50 lines long, right? So this is an approximation of what you'd do. But in Option 1, you've got one big complicated piece of code 100 lines long. In Option 2, you've got 3 pieces of code, 2 of which are 50 lines long. But the complexity of each individual function, if you're measuring in terms of lines of code, is less in Option 2 than in Option 1. So presumably, Option 2 would be easier to debug. Now, this all depends on a bunch of other factors. So for instance, you don't want to take a piece of code that's 100 lines long and just chop it straight in half. And say, the top half's function 1, bottom half's function 2, right? You've gotta group the functions in a reasonable way. We already talked about this. Each function should map to an operation that makes sense in your application. So you can't, typically you can't just cut it in half. But you might be able to take this 100 line piece of code and say, well, the fist 30 lines do this and the next 70 lines do that and maybe chop it up like that. And even that's an improvement, right? And then you can take the 70 line piece of code, that 70 line function, and chop that up into a 30 line chunk and a 40 line chunk and so on. So there's this decomposition and hierarchy that you're making implicitly when you define these functions. And the goal is, part of the goal is, to make sure that each individual function isn't too complex, okay? So you limit the complexity. Now, in this case, we're talking about complexity in terms of lines of code. But we'll talk about another form of complexity next.
Play video starting at :3:54 and follow transcript3:54
Control-flow complexity, so another way to look at the complexity of a piece of code is to look at how complicated its control-flow is. So when I say control-flow, I'm talking about the paths from the top of the function to the bottom, from the start to the end, the control-flow paths. So how many options there are? So, for instance, if you had a piece of code that had no if statements, just straight line code. Just a sequence of assignments, let's say, assign, assign, assign, assign, assign. That has exactly 1 control-flow path from top to bottom. There is 1 sequence of instructions that you will execute in that code, so 1 control-flow path. But if you put an if statement in there, if this is true, you do one thing. If that's true you do the other. If you put 1 if then you've got 2 paths.
Play video starting at :4:38 and follow transcript4:38
Now code gets more complicated than that. You can have nested if statements, you could have loops, which are implicitly conditional statements, and things like this. So a typical function can have many different control paths, many different sequences of instructions that are executed when you execute that code. Many different sequences that execute depending on the input parameters, right? So here I got this function, foo, and it's got 2 conditions. Well, actually, one is nested within the other. So if a == 1 than you go into this next conditional if b == 1. So if I look at this code, I would say this has 3 control-flow paths. Assuming there's no other control-flow operations here, you got 3 paths, 3 paths. 1 is where a == 0, a is not equal to 1. If a is not equal to 1, then you skip that whole inner conditional, if b == 1. And you just finish and go to the end, okay? So that's one path, a is not equal to 1. Then another path is a == 1, but b is not equal to 1. Then another path is a == 1 and b == 1. And each one of those 3 sets of conditions, you are executing a different sequence of instructions inside this program. So there are 3 control-flow paths inside this piece of the code. Now, one way to measure the complexity of a piece of code is how many control-flow paths it have? So I can say, look this has 3. So, say I want to simplify that, and I might be able to use functional partitioning to reduce the control-flow complexity a little bit.
Play video starting at :6:10 and follow transcript6:10
So, say I take that function, foo and now I take, remember it had 2 conditionals, right? So now what I've done is I defined 2 functions. And I've separated the conditionals, split them out across the 2 different functions. So now foo still has the first conditional, if a == 1. Still got that, but then the next conditional check doesn't exist anymore inside that function. Instead it calls a function called CheckB. Now if you look at CheckB on the other side, that has the other conditional, if b == 1, then whatever. So I've separated these 2 conditionals, now, now that I've done this, the foo function now has 2 paths through it, a == 1, and a is not. And then CheckB, it has 2 paths, b == 1 and b is not. So now each 1 of these functions has 2 control-flow paths instead of the 3 control-flow paths that I had when I merged them together, okay? So this is just a tiny example, but the idea is you could separate the conditionals into different functions and reduce the max complexity, right, the max number of control-flow paths. You can reduce that overall, making the code easier to debug, typically. Thank you.